<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Entradas recientes</title>
  <id>http://localhost/feed.atom</id>
  <updated>2015-01-27T00:00:00Z</updated>
  <link href="http://localhost/" />
  <link href="http://localhost/feed.atom" rel="self" />
  <generator>Werkzeug</generator>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">git-flow para contribuir features</title>
    <id>git-flow</id>
    <updated>2015-01-27T00:00:00Z</updated>
    <published>2015-01-27T00:00:00Z</published>
    <link href="/#/post/git-flow" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">

Git-flow son un conjunto de sugerencias para trabajar en un proyecto
colaborativo que reduce algunos de los problemas potenciales de tener muchos
desarrolladores en un proyecto. Afortunadamente, existen varias herramientas
que estandarizan dichas sugerencias y facilitan sus funciones. En este caso
revisamos el _workflow_ de desarrolladores que contribuyen con _features_ al
proyecto.

Instalación
===========

Una de las herramienta populares es: _git-flow_ para instalarla en Ubuntu, se
hace lo siguiente:

``` bash
apt-get install git-flow
```

Para otras versiones de [linux](https://github.com/nvie/gitflow/wiki/Linux),
[macs](https://github.com/nvie/gitflow/wiki/Mac-OS-X ) y
[winddows](https://github.com/nvie/gitflow/wiki/Windows).


Branches
========

Git-flow propone utilizar los siguientes _branches_

* _master_ contiene únicamente información de los release
* _develop_ contiene todo la historia de desarrollo
* _feature-*_ son branches temporales para creación de _features_

Ejemplo: authorprof
===================

El siguiente ejemplo muestra como un desarrollador de _features_ puede
contribuir a un proyecto que use la propuesta de _Git-flow_.

Clonar el código
----------------

En este caso el código radica de manera central en
[github](http://github.com), pero lo necesitamos en nuestra máquina para
comenzar a _hackear_.  Para esto clonamos el código de nuestra cuenta a
nuestra máquina con la siguiente instrucción:

``` bash
git clone https://github.com/ivanvladimir/authorprof.git
```

En este caso asumimos que somos colaboradores del proyecto en cuestión ya que
está sobre la plataforma [github](http://github.com). De otra forma habría que
darle la vuelta con _forks_ y _pull-requests_o poniendo una plataforma
independiente para nuestro repositorio.


Inicializar código
-----------------

Para crear los _brach_ que propone _Git-flow_ podemos hacer lo siguiente en el
directorio de nuestro proyecto (_authorprof_):

``` bash
git flow init
```

Y contestar las preguntas a nuestras preferencias. Muy probablemente _master_
y _develop_ ya estén incluidas en el repositorio.


Comenzar un _feature_
----------------------

Con nuestra copia y en el _branch_ de desarrollo, podemos comenzar a trabajar
en nuestro _feature_, con la siguiente instrucción:

``` bash
git flow feature start NOMBREFEATURE
```

Codificar mi tarea
------------------

En este momento podemos a trabajar en nuestra tarea con toda confianza y
libertad. Podemos hacer las operaciones normales de ir programando nuestro
código, y hacer las operaciones con _git_ que necesitemos.

``` bash
git status
git commit
git add
```

Una intrudicción rápida a _git_ puedes encontrarla
[aquí](/#/post/git_basico).

Una vez que hayamos finalizado con nuestro _feature_ lo podemos finalizar con
la siguiente instrucción:

``` bash
git flow feature finish NOMBREFEATURE
```

Esta es la etapa en la que estaremos la mayor parte del tiempo.

Compartir mi tarea
------------------

Una vez terminada con mi tarea, podemos compartir nuestro código, para que sea
integrado a la _branch_ de _develop_:

``` bash
git flow feature publish NOMBREFEATURE
```


Mas allá
========

Lo anterior es el ciclo del desarrollador, además existe el ciclo del
encargado de hacer _releases_ y de arreglar _bugs_ (hotfixes).


Material Extra
==============

* [Filosofía de
Git-flow](https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow)
* [Proyecto de git-flow y documentación](https://github.com/nvie/gitflow)
* [Cheatsheet de
Git-flow](http://danielkummer.github.io/git-flow-cheatsheet/)
* [Comenzando con Git-flow](http://yakiloo.com/getting-started-git-flow/)
* [Instalación de
_git-flow_](https://github.com/nvie/gitflow/wiki/Installation)
* [Complemento de _git-flow_ para</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Toolkit de Stanford CoreNLP</title>
    <id>nlp_core</id>
    <updated>2015-01-25T00:00:00Z</updated>
    <published>2015-01-25T00:00:00Z</published>
    <link href="/#/post/nlp_core" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">

&lt;br/&gt;
&lt;p class=&quot;panel&quot;&gt;
Estas notas se basan en la versión 3.5.0 del toolkit
&lt;/p&gt;

[Stanford CoreNLP](http://nlp.stanford.edu/software/corenlp.shtml) es un
toolkit de herramientas para el procesamiento del lenguaje natural basada en
modelos estadístico. Actualmente es muy interesante para nosotros porque poseé
herramientas para el español.

Requerimientos
==============

Requiere del JDK versión _1.8_. Para verificar si tienen esta versión
ejecutar:

``` bash
$ java -version
java version &quot;1.8.0_31&quot;
Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)
```

Si la respuesta no coincide con la versión  _1.8_ sigue las instrucciones
[aquí](http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/)

Instalación
===========

Primero bajar el archivo con el código fuente de
[aquí](http://nlp.stanford.edu/software/stanford-corenlp-full-2014-10-31.zip)

Después descomprimir _.zip_:

``` bash
$ unzip stanford-corenlp-full-2014-10-31.zip
$ mv stanford-corenlp-full-2014-10-31 corenlp
```

Finalmente bajar los  _jars_ adicionales y ponerlos en el directorio
_corenlp_:

* Modelos para el
[español](http://nlp.stanford.edu/software/stanford-spanish-corenlp-2014-10-23-models.jar)
* Modelos para el
[parser](http://nlp.stanford.edu/software/stanford-srparser-2014-10-23-models.jar)

Pruebas con español
===================

Primero crear un archivo con frases en español, por ejemplo: _test.txt_.

Después, ejecutar la siguiente línea:

``` bash
$ java -cp &quot;*&quot; -Xmx2g edu.stanford.nlp.pipeline.StanfordCoreNLP\
-annotators tokenize,ssplit,pos,parse -outputFormat &quot;text&quot; \
-parse.model edu/stanford/nlp/models/srparser/spanishSR.ser.gz \
-tokenize.language es
```

El significado de los parámetros son:

* Que cargue todos los paquetes de java _-cp &quot;*&quot;_
* Que ejecute el programa principal StanfordCoreNLP
* Que encadene una secuencia de tareas _-annotatorstokenize,ssplit,pos,parse_
:
* tokenize: identificar las palabras
* ssplit: identificar la oraciones
* pos: asignar a cada palabra su categoria gramatical
* parse: identificar la estrucutra sintáctica principal
* Que el formato de la salida sea texto _-outputFormat &quot;text&quot;_
* Que para el parser use el modelo de español _-parse.model_
_edu/stanford/nlp/models/srparser/spanishSR.ser.gz_
* Que para separar las palabras se base en español _-tokenize.language es_

Una vez ejecutada la línea aparecerá un prompt _NLP&gt;_ puedes escribir un texto
en español y te debe regresar el análisis sintáctico:

``` bash
NLP&gt; esta es una oración de prueba
Sentence #1 (6 tokens):
esta es una oración de prueba
[Text=esta CharacterOffsetBegin=0 CharacterOffsetEnd=4 PartOfSpeech=FW]
[Text=es CharacterOffsetBegin=5 CharacterOffsetEnd=7 PartOfSpeech=FW]
[Text=una CharacterOffsetBegin=8 CharacterOffsetEnd=11 PartOfSpeech=FW]
[Text=oración CharacterOffsetBegin=12 CharacterOffsetEnd=19
PartOfSpeech=FW] [Text=de CharacterOffsetBegin=20 CharacterOffsetEnd=22
PartOfSpeech=FW] [Text=prueba CharacterOffsetBegin=23
CharacterOffsetEnd=29 PartOfSpeech=FW] (ROOT
(sentence
(sn
(spec
(grup.cc (FW esta) (FW es))
(FW una))
(grup.nom (FW oración)
(s.a
(grup.a (FW de)))))
(FW prueba)))
```

Material Extra
==============

* [Artículo describiendo el
sistema](http://nlp.stanford.edu/pubs/StanfordCoreNlp2014.pdf)
* [Página con más software](http://nlp.stanford.edu/software/index.shtml)</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Actividades extra a la escritura de la tesis</title>
    <id>como_escribir_la_tesis_extra</id>
    <updated>2014-08-30T00:00:00Z</updated>
    <published>2014-08-30T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_extra" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">

En la suma de los trámites burocráticos al final lo único que importa es que
tengas tu escrito. Sin embargo hay algunas actividades alternativas a la
escritura de la tesis que pueden complementar y mejorar tu trabajo y
contribuir a la evidencia de la calidad de tu investigación. Sin embargo,
repito en lo burocrático lo único que importa es que tengas el escrito de tu
documento, por lo que si estas actividades se interponen en el avance debes
estar en la mejor disposición de abandonarlas.

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/dancing.jpg' title=&quot;No distracciones&quot;/&gt;
&lt;/center&gt;

Llevar una bitácora
===================

Registrar el avance de tu investigación muy recomendable. En está puedes
registrar experimentos y resultados o ideas que te surgen durante la
investigación. Puedes incluir evidencia gráfica como fotos o diagramas. Esta
actividad puede ser más ambiciosa y puedes crear un blog donde escribas sobre
los conceptos que estás aprendiendo. Algunas partes de estas secciones pueden
ser utilizadas en tu tesis después. Tanto para la bitacora o blog puedes usar
las plataformas actuales de la web y así exponer tus ideas a un público
general y con suerte así recibir retroalimentación sobre tu trabajo.

Dar pláticas
============

Conforme avances en tu investigación puedes exponer tu investigación en forma
de plática tu investigación y tus ideas. Hacerlo ante un público permitirá que
explores diferentes formas de estructurar tus argumentos y veas de primera
mano como reaccionan ante éstos personas ajenas a tu investigación. En la
sección de preguntas y respuestas puedes identificar que no estás explicando
bien, o pueden surgir nuevas ideas tanto de investigación o de como presentar
tu trabajo.

Escribir un artículo
====================

Existen diversos foros que podrían beneficiarse de una versión resumida de tu
investigación. Dependiendo de la naturaliza podrías escribir un artículo de
divulgación donde promueves la importancia de tu investigación en un lenguaje
muy genérico para un público general. O también si lograste avanzar el estado
de arte con tu trabajo podrías publicar en un foro especializado un artículo
científico. En particular esta actividad conviene que la lleves a cabo con tu
supervisor que debe tener experiencia en este ámbito.

Platicar de tu tema
===================

Esta no es una actividad que ponga en riesgo la escritura de tu tesis como las
anteriores, a menos que sea lo único que hagas :-) Pero yo recomiendo que
intentes platicar con todo mundo lo que haces: tu familia, tus amigos, niños,
adultos mayores, etc. Esto te pone ante un reto porque a veces lo harás ante
gente que no es de tu área y no está en el mismo canal. Pero entre más
platiques, encontrarás nuevas formas de presentar tu trabajo y nuevos
argumentos que beneficiarán la escritura de tus argumentos en tu tesis. Como
las pláticas informalies son interactivas tu interlocutor podrá detenerte y
tratar de aclarar lo que no le quede claro, y de esta forma podrás tener una
mapa de que es lo que funciona o no de la forma que explicas.  Conviene que
practiques explicaciones largas o cortas, el famoso &quot;elevator speech&quot; en donde
dices lo que haces en un viaje de elevador ;-)</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">La conlusión en la tesis</title>
    <id>como_escribir_la_tesis_conclusion</id>
    <updated>2014-08-27T00:00:00Z</updated>
    <published>2014-08-27T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_conclusion" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">
¡¡ Felicidades, ya te encuentras escribiendo las conclusiones !! Aunque es uno
de los capítulos más importantes de tu escrito, en realidad no es muy difícil
de escribirlas.

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/keep-calm-and-backup-the-files.png'
title=&quot;Escribiendo la tesis&quot;/&gt;
&lt;/center&gt;


El capítulo se divide en dos partes. En la primera describes de manera concisa
los resultados que alcanzaste, nada más que en lugar de verlos de forma
independiente los tienes que poner en forma global. En este capítulo,  es muy
común encontrarnos con una explicación de como los resultados obtenidos
demuestran que logramos los objetivos planteados en tu introducción. Esta
parte puede ser muy repetitiva ya que se menciona de nuevo los logros
alcanzados nada más con ese sabor que en lugar de ser una secuencia de pasos
son uno sole elemento.  También puedes incluir una lista de tus contribuciones
al campo como: publicaciones, sistemas, código, conclusiones, etc.  Estas son
cosas que no estaban antes de que comenzaras la tesis y que ahora al final, ya
existen al beneficio de todos.

La segunda parte es un poco especulativa. Primero describes de manera
argumentativa que significa para el campo los resultados alcanzados, a lo
mejor puedes ver una relación con una problemática global, o una avance en el
campo, etc.  En segundo lugar puedes especular sobre que más se puede hacer
tanto para avanzar en tus logros como qué otra investigación se podría hacer
dado lo que alcanzaste.  Puedes argumentar desde pasos lógicos como nuevos
experimentos, hasta otro tipo de investigación. Por supuesto, aunque
especulativo debe estar argumentado y basado en la honestidad de que realmente
ves una relación entre tu trabajo y lo expuesto.

</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Las correcciones del supervisor</title>
    <id>como_escribir_la_tesis_correcciones</id>
    <updated>2014-08-26T00:00:00Z</updated>
    <published>2014-08-26T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_correcciones" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">

Durante la realización de tu tesis, tú y tu supervisor tendrán una relación
muy especial donde convivirán, platicarán y se apoyarán para que tu
investigación sea de exhaustiva, robusta y adecuada para tus tiempos e
intereses. Sin embargo, el proceso de recibir correcciones por parte de tu
supervisor puede hacer la relación un poco difícil :-)

Lo primero que tienes que entender es que es natural sentir algo negativo
cuando se te regresa el texto corregido. Después de todo es el trabajo al que
te has dedicado los últimos días o semanas, y que este esté todo rayoteado
pareciera desacreditarlo. Pero inmediatamente tienes que controlar ese
sentimiento y poner en perspectiva esas correcciones, y entender que las
correcciones buscan complementar tu trabajo no sustituirlo, y la siguiente
versión será sin lugar a dudas mejor.

&lt;center&gt;
&lt;a href=&quot;http://www.phdcomics.com/comics/archive.php?comicid=690&quot;&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/phd030706s.gif'
title=&quot;Respalda ante todo&quot;/&gt;&lt;/a&gt;
&lt;/center&gt;


Tipos de corrección
===================

En el documento corregido habrá varios correcciones que las podemos clasificar
de las siguiente forma de menor a mayor _gravedad_:

* *Errores de dedo*: Estos son pequeños errores generalmente de ortografía o
puntuación. En las primeras versiones de tu tesis tendrás muchisimos de éstos,
pero conforme avances irán siendo menores. Si un error persiste es
recomendable leer sobre las reglas de ortografía o puntucación.
* *De estilo*: Estas son correcciones sobre el formato de tu documento, uso de
marcas como cursivas, citas, formatos de figuras, tablas, etc.
* *De estructura*: Estas correcciones piden que re-estructures secciones o
párrafos. Generalmente esto se da porque la línea de argumento no coincide con
la estructura. Por ejemplo, si se menciona algún elemento que se describe
después.
* *De redacción*: Estos son errores gramaticales que hacen difícil
entender alguna oración o par de ellas (conjugaciones o tiempos incorrectos,
conexión de oraciones, repeticiones de ideas).  Igual que los errores de dedo
con la práctica se irán haciendo menor. Mi recomendación es si tienes alguna
duda sobre algún error en específico leas sobre el problema y busques ejemplos
similares en otros documentos, google facilita mucho este proceso.
* *De argumento*: Estás son correcciones sobre tus argumentos: si estás
diciendo algo que no es cierto, si no provees la evidencia de lo que dices, si
te estás quedando corto con los alcances de tus ideas, si existe alguna
contradicción, o si algún argumento en realidad no contribuye a tu discusión.
* *De lenguaje*: Estos son correcciones sobre tu forma de escritura, si usas
un lenguaje coloquial, rebuscado o de plano no se te entiende.

Como corregir
=============

Una vez que te entregan las correcciones conviene que las repases con tu
supervisor, sobretodo él te debe hacer comentarios sobre cuales cree que sean
los puntos más importantes a corregir. Estos deben concentrarse en errores de
argumento o de lenguaje, escucha con atención sus comentarios y opiniones de
como corregirlo.

De preferencia, en cuanto recibas las correcciones, en la próxima  sesión de
escritura de tu tesis debes trabajar sobre los primeros tres tipos de
correcciones de un jalón: corregir errores de dedos, de estilo y de
estructura.  Este tipo de correcciones son muy mecánicas y es muy difícil que
produzcan errores mayores, por lo que puedes ir una por una hasta acabar con
ellas. Una vez hecha estas correcciones puedes repasar el texto corregido,
esto puede ser en otra sesión, y hacer las correcciones de redacción. Este
proceso requiere mayor atención y concentración, pero puedes aprovecharlo para
verificar que las correcciones previas no hayan provocado otros errores.

Para corregir errores de argumento, debes repensar la manera en que expones
tus ideas. Para esto conviene que hagas un mini-plan de textos que complemente
o sustituya a los argumentos que están siendo corregidos. Muy probablemente tu
supervisor te dio un par de sugerencia de como corregir, explóralas y decídete
por una solución. Aplícala, y no dediques mucho tiempo a un sola corrección.

Finalmente, para las correcciones de lenguaje son las más graves, porque
básicamente significa que todo el texto a corregir no es útil y debes
re-escribirlo usando otro tipo de lenguaje. Revisa las recomendaciones del
post sobre el lenguaje de tu tesis, escribe más simple, y lee otras tesis en
el área. Y disponte pasar un tiempo en encontrar el tono adecuado para tu
texto.

Una vez que tienes una versión corregida, dale una lectura extra y revisa que
no se te pase nada. Un punto de molestia para tu supervisor es corregir dos
veces el mismo error, así que evita esa situación en la medida de lo posible.


Relación con tu supervisor
==========================

Una vez que tienes corregido tu texto puedes continuar con la escritura de
nuevos capítulos y secciones, pero es recomendable que envíes la versión de tu
tesis con estas correcciones a tu supervisión. De hecho mi consejo es no dejar
pasar mucho tiempo entre ciclo de corrección, ésto está basado en mi
experiencia como supervisor. Mi opinión sobre un texto cambia con el tiempo, y
entre más tiempo pase tengo más opiniones que se traducen en mas correcciones.
De hecho he notado, que en ocasiones me contradigo en las correcciones. Pero
si pasa poco tiempo, mi opinión no cambia tanto y las correcciones son
consistentes.

Un problema que puede surgir es que tu supervisor no te entregue correcciones
al ritmo que tu produces versiones de tu texto, en la medida de lo posible
trata de recordarle que te debe correcciones. Pero si esta descoordinación
continua busca retroalimentación de otras personas: compañeros de laboratorio,
amigos de carrera o familiares; y modera tus entregas con él.

Una situación normal que ocurre es que tú también tienes opiniones sobre tu
texto, y algunas veces no vas a estar de acuerdo con las correcciones de tu
supervisor, después de todo con el tiempo te estás convirtiendo en el experto
del tema y tu tendrás una mejor perspectiva de tu trabajo. Tu supervisor debe
ser flexible para aceptar tus opiniones, sin embargo esto puede generar
situaciones complicadas dependiendo de las personalidades involucradas. Mi
consejo es si se llega a uno de estos puntos, consideres la sugerencias de tu
supervisor, inténtalas y ve si el texto mejora; si crees que el texto empeora
o no trasmite lo que estás haciendo de investigación busca argumentos
alternativos y promueve la discusión con tu supervisor, pero si debes evitar
el antagonismo. En casos extremos cede y sigue la recomendación de tu
supervisor al pie de la letra, y continua con otras partes de tu texto.

</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">El ritual de escribir la tesis</title>
    <id>como_escribir_la_tesis_ritual</id>
    <updated>2014-08-24T00:00:00Z</updated>
    <published>2014-08-24T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_ritual" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">
La tarea de crear el documento de la tesis puede ser sumamente frustrante sino
tenemos la disciplina de escribir. El proceso de sentarnos enfrente de nuestro
documento cotidianamente para escribir idea tras idea en un documento extenso
no es muy natural en la vida estudiantil, sobretodo para estudiantes de
ingenierías y áreas computacionales, en donde esta habilidad es poco
cultivada. Y tener que hacer esto para el proyecto final de nuestros estudios
lleva una carga emocional que aunado a la falta de experiencia puede hacer el
proceso sumamente doloroso.  Afortunadamente podemos &quot;hackearnos&quot; en adquirir
la disciplina y hacer del proceso una experiencia agradable, aquí algunas
ideas.

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/cat_ritual.jpg'
title=&quot;Respalda ante todo&quot;/&gt;
&lt;/center&gt;


Errores comunes
===============

Antes de hablar de las sugerencias es bueno mencionar las estrategias que
harán dolorosa la escritura:

* Esperar por la inspiración: Aunque escribir es un proceso creativo, nuestra
documento es un reporte en extenso que no se beneficia mucho de si estamos
inspirados o no, por lo que esperar a que las estrellas se alinean para
avanzar en el texto no es recomendable. Con inspiración o sin ella, lo mejor
es tener un par de hojas más en nuestro documento hoy a esperar al día que la
inspiración nos llegue ;-)
* Esperar hasta el último: Varios alumnos tienen la experiencia que un día
antes de una fecha de entrega pueden hacer su tareas con muy buenos
resultados, bajo la presión de tiempo encuentran más fácil concentrarse,
trabajar y aprender. Sin embargo, esta es una mala idea con la tesis, en
principio porque la mayoría de las veces no hay una fecha de entrega final
real. Pero además esta estrategia da muy poco chance de un ciclo de edición de
parte de los supervisores, produciendo un documento muy mal escrito.
* Separar investigación de escritura: Dejar la escritura para después de hacer
la investigación no es tan buena idea ya que nos olvidamos de detalles
importantes, pero sobretodo estructurar nuestras ideas para la escritura del
documento puede influenciar nuestra investigación de manera positiva, por
ejemplo podemos definir nuevos experimentos complementarios que ayuden a
comprender nuestras propuestas, cosa que si ya cerramos el ciclo de
investigación no sería tan fácil de llevar a cabo.
* Perfección: Escribir con la intención de que los capítulos, las secciones,
los párrafos o la palabras sean nada menos que perfectas también es un error.
La calidad del texto se puede alcanzar de manera progresiva si iteramos sobre
nuestro texto y en la medida que varios ojos pasen por él y te hagan
observaciones y comentarios que enriquezcan el documento. Repito lo más
importante de la tesis es la investigación, ésta es la que tiene que ser
perfecta y exhaustiva, la tesis es solo un documento en extenso de la
investigación.

Rituales
========

Mi recomendación para adquirir la disciplina de escribir es crear un ritual al
rededor del proceso. El propósito de este ritual debe indicarnos que en esa
siguiente hora o par de horas vamos a escribir. El ritual es algo personal y
cambia mucho de persona a persona, uno debe intentar diferentes opciones hasta
encontrar lo que funciona con uno. Los siguientes son algunos ejemplos de
rituales que he visto algunos alumnos han desarrollado con mucho éxito:

* En lo personal el ritual que funciona para mí es ir a un café con mi
laptop y ahí escribir. Algunos aspectos que complementan el ritual son por
supuesto tomar alguna bebida (café funciona muy bien ;-), escuchar música con
los audífonos y usar siempre el mismo editor (vim ;-). Esta situación me
indican que es tiempo de escribir.
* De varios alumnos he escuchado que ellos escriben mejor de noche, su ritual
consiste en antes de dormirse sentarse ante su documento y escribir un tanto.
En general esto hace que usen sus máquinas personales para la escritura que
adecuaban de la mejor forma posible.
* Otro alumno me contó que para lo que el funcionaba era escribir recién
levantado, con café en la mano se sentaba ante su documento y escribía hasta
que era hora de desayunar.
* En una alumna he notado que ella primero escribe su plan e ideas centrales
en una hoja generalmente esto lo hace en su casa, y cuando llega al
laboratorio escribe el texto durante la mañana en su laptop personal
directamente.

Lo esencial del ritual, es que una vez hecho podemos continuar nuestra vida
cotidiana, tanto como antes y después de este. El ritual nos permite definir
el tiempo del día que se lo dedicaremos a escribir. El ritual tampoco se
interpone a las distracciones cotidianas como son el celular o las redes
sociales, pero sí hay que buscar que durante nuestro ritual escribamos más que
distraernos ;-).

Si tienes algún ritual que funcione para ti no dudes de platicarnos acerca de
él en la sección de comentarios.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Figuras, tablas, algoritmos, código, fórmulas y citas en la tesis</title>
    <id>como_escribir_la_tesis_figs_refs_etc</id>
    <updated>2014-08-23T00:00:00Z</updated>
    <published>2014-08-23T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_figs_refs_etc" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">

Además del texto es muy útil para presentar y organizar nuestro contenido usar
figuras, tablas, algoritmos, código y fórmulas. Ya que todos conocemos el
dicho: *una figura o una tabla o un algoritmo o un código o un fórmula dice
más que mil palabras* :-)

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/neil_figs.jpeg'
title=&quot;Respalda ante todo&quot;/&gt;
&lt;/center&gt;


Referencias
===========

Todos estos elementos comparten la propiedad que podemos hacer referencias de
ellos desde nuestro texto. De hecho a estos elementos se suman las secciones y
los capítulos. Entonces en nuestro texto podemos tener algo como lo siguiente:

* En la sección 3.3 del capítulo 3, se presentó la Tabla 3, que resume los
datos presentados en la Figura 8 y que fueron calculados con la Fórmula 3,
cuyo calculo se hizo con el Algoritmo A y su respectivo Código 3.

Como pueden observar hacemos uso a la numeración de cada uno de estos
elementos los cuales poseén una enumeración independiente uno de otro. Tanto
herramientas como Office, LibreOffice o Latex generan y actualizan esta
numeración conforme escribimos el contenido, por lo que no tenemos que
preocuparnos por generarla.  En particular, en Latex lo anterior se logra
usando las marcas  *label* y *ref*.

Como también pueden observar, existe un estílo de que vá con mayúscula y que
no:
* _Mayúscula_: Figura, Tabla, Algóritmo, Código y Fórmula
* _Minúscula_: Capítulos y secciones
Hay quienes prefieren usar todo con mayúsculas, lo importante es ser
consistente durante nuestro documento, decidirnos por un estilo y conservarlo.

Con este estilo de hacer referencias estos elementos pueden estar úbicados en
cualquier parte de nuestro documento. Por lo que no es nesesario usar frases
como: _como se muestra en la siguiente figura_, _la siguiente tabla resume
estos resultado_, etc. En particular Latex toma control de la úbicación de
estos elementos y lo hace tomando desiciones en términos estéticos. El único
elemento que elude este estilo y generlamente va intercalado con nuestro texto
es el de las fórmulas.

Citas
=====

Adicional al contenido extra dentro de nuestra tesis  podemos hacer referencia
a trabajos externos como árticulos, otras tesis, libros, etc. A esta situación
la denominamos como citar trabajos. Las citas van más allá que simplemente
hacer una referencia al trabajo externo, tienen la misión de reconocer la
autoría de una idea o resultado. También lo usamos para descargar la necesidad
de justificar alguna idea o resultados, ya que podemos aludir al trabajo en el
que nos basamos.

La citas son un punto de honradez de nuestra tesis donde reconocemos que ideas
son nuestras y cuales no. Las citas que se hagan para criticar de forma
positiva y negativa alguno trabajo también tienen que basarse en la honradez
de que sabemos de lo que hablamos y conocemos el trabajo criticado.

Éstilos
-------

Para hacer una cita hacemos una marca que permita identificar el trabajo
citado en el texto (por ejemplo un número o los apellidos del autor).  Al
final de nuestra tesis incluimos la bibliografía que es la lista de todos los
trabajos citados en nuestro documento. La marca escogida debe facilitar la
identificación del trabajo en la lista, la lista contiene una descripción del
trabajo que debe facilitar su identificación en medios impresos o
electrónicos. En nuestro texto podemos hacer multiples referencias a los
trabajos con su debida mesura.

Existen multiples estilos de marcas y de como presentar la bibliografía,
usalmente correspondiente entre ellos. Por ejemplo, si se enumeran en la
bibliografía la cita puede ser a través de un número. Si se listan
alfabéticamente la cita puede ser a través del apellidos del primer autor y el
año de publicación. Para saber una opción de como lucen las descripciones de
la citas pueden visitar mis
[publicaciones](/#/publications) ;-)


Afortunadamente herramientas como Word, LibreOffice y Latex contienen
herramientas para manipular los estilos y la información. En estos sistemas
básicamente capturamos los trabajos en una base de datos, y dependiendo de las
menciones en el texto se genera la lista y las citas en el formato adecuado.

Otra vez la recomendación es escoger un estilo y ser consistente con ese
estílo durante nuestro documento. Si usamos una de las herramientas de los
editores, cambiar de estilo  es súmamente fácil.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">El lenguaje a usar en la tesis</title>
    <id>como_escribir_la_tesis_lenguaje</id>
    <updated>2014-08-22T00:00:00Z</updated>
    <published>2014-08-22T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_lenguaje" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">
&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/cat_language.jpg'
title=&quot;Introducción de la tesis&quot;/&gt;
&lt;/center&gt;

La tesis es un documento formal del cual se espera que el lenguaje también lo
sea. Estas son buenas noticias si escribir no está en tu naturaleza ya que del
documento se espera que sea conciso, formal y argumentativo, condiciones que
no son tan difíciles de lograr si tus objetivos e ideas están claras y si la
organización de tu tesis es correcta. Esto no significa que si está en tu
naturaleza ésto lo puedas usar a tu favor e impregnarla de un sabor más
creativo a tu tesis. A continuación algunos sugerencias para alcanzar el
estilo de lenguaje formal que es la base para la tesis.

Corrector de ortografía
-----------------------

Tener prendido el corrector de ortografía es fundamental, aunque estos no son
totalmente infalibles si ayudan a limpiar muchos de los errores comunes,
pequeños e insignificantes  que al corregirlos lo más pronto posible
permitirán que te enfoques a errores mayor complejidad. Así que siempre ten
prendido el corrector de ortografía... por favor!


Oraciones cortas
----------------

El español es muy generoso y podemos construir con el oraciones largas que son
de lo más naturales en nuestra comunicación diaria, tanto en lenguaje escrito
como hablado.  Esto hace natural que si es la primera vez que escribimos un
documento recurrir a oraciones largas y explicativas, sin embargo pasar del
lenguaje hablado al lenguaje escrito formal usando oraciones largas no es nada
fácil y requiere de mucha práctica que muy difícilmente vamos a poseer en
nuestro primer documento. Para evitar esta situación recomendamos usar
oraciones cortas, una por idea unidas por conectivos. Los siguientes son
ejemplo de los dos casos:

* *Oración larga*: La interpretación de una oración depende de la secuencia
de palabras que la componen ya que  una palabra en cualquier posición afecta
al significado de la siguiente y en su totalidad todas la palabras hacen
surgir el significado que nos ayuda a entender lo que una persona quiere decir
cuando habla o escribe algo para que nosotros podamos reaccionar o evocar de
forma adecuada lo significado por el o ella.
* *Oraciones cortas*: El proceso de la interpretación nos permite reaccionar a
a lo significado o evocarlo cuando alguien habla o escribe.  Este significado
surge de la interpretación de las palabras que la componen.  En su conjunto
todas las palabras contribuyen al significado total de la oración.

Por supuesto recaer mucho en oraciones cortas puede producir un texto un tanto
robótico. Sin embargo, es mucho más fácil editar este tipo de texto ya que las
ideas principales ya están ahí y solo hay que entrelazarlas.

En términos prácticos, si ves que una oración se alarga más de cuatro
renglones quiere decir que requiere ponerle atención. Si la oración es de
medio renglón, también requiere de atención. Es totalmente válido si después
de prestarle atención y de evaluar su re-escritura estás cómodo con ella,
dejarla en el texto.

Lenguaje sencillo
-----------------

Dependiendo de los hábitos de lectura de cada quien recurre a patrónes o
frases que uno a leído con frecuencia; otras veces estos provienen de lo que
percibimos que es formal. Estos patrones generalmente son complejos e incluyen
construcciones rebuscadas. En general la recomendación es recurrir a lenguaje
sencillo. La complejidad e importancia de nuestro tema surgirá de entrelazar
las ideas básicas de nuestro tema y no del uso de estos patrones. Por lo que
conviene identificarlos y valorar su necesidad.


Adjetivos y adverbios
---------------------

En el español de México también es común usar adjetivos para matizar nuestras
expresiones. Es como si escribiéramos en dos dimensiones una con el contenido
esencial y otra emocional. Por ejemplo en la oración: *la reacción química
produjo una luz muy verde*. La palabra *muy* sobra en el lenguaje formal, es
suficiente con describir *la reacción química produjo una luz verde*. Si
existe la necesidad de matizar el resultado podemos recurrir al detalle: *luz
de color verde subido&quot; o la descripción *En particular la tonalidad del verde
fue intenso*.

Párrafos
--------

Los párrafos los usamos para aglomerar un conjunto de ideas coherentes.
Nosotros como escritores decidimos cuanto alargar nuestro párrafo. Ser dónde
parar un párrafo también es una habilidad a aprender. Párrafos que se
extiendan cercano a una página o de una sola oración requieren atención y
revisión.

Repetición
----------

Algo común durante la escritura es recurrir a repetir una serie de palabras en
un párrafo, párrafos continuos o una sección completa.  Sino es el tema
central de nuestro texto muy probablemente podemos re-escribir estas palabras
o la idea del párrafo para evitar la repetición. El uso de diccionarios de
sinónimos o antónimos puede ser útil para agilizar la re-escritura.

Secciones
---------

Las secciones nos ayudan a organizar nuestro contenido en unidades
argumentativas y lógicas. Las secciones tienen un título que especifican de
qué van a hablar los párrafos que continúan. En términos computacionales
podemos pensar como un árbol que define el alcance de las relaciones entre el
contenido. Un subsección contenida en una sección no tiene mucha relación con
otra de otra sección.  Sin embargo, recordemos que el texto es plano y
consecutivo y una subsección puede hacer referencia al contenido de una
anterior.

Entradas y salidas
------------------

Un formato de escritura de tesis que facilita la lectura es incluir entradas y
salidas. Estos son párrafos al inició o final de capítulos o secciones
importantes. Al inicio estos párrafos tienen el objetivo de ubicar al lector
en el capítulo o sección. Es una pequeña explicación que revisa que es lo que
vamos a ver en el capítulo o la sección, lo motiva en el contexto de lo que
hemos visto y lo prepara para los argumentos principales que vamos a
presentarle.

Al final la salidas tienen el objetivo de recapitular y enlazar el estado de
lo dicho en ese capítulo o sección con lo que sigue. A veces la escritura de
estos párrafos puede parecer repetitivo porque sobre-explica la estructura de
la tesis, sin embargo generalmente se aprecian ya que ayuda a una lectura
dirigida.

El proceso de escritura
========================

Durante este texto hemos hablado de algunos aspectos a los que hay que ponerle
atención durante la escritura de la tesis. Sin embargo, mientras escribimos es
difícil concentrarnos en estos aspectos ya que escribir es un proceso
cognitivo en si altamente demandante. Pero no es necesario hacer las dos cosas
en paralelo, mi sugerencia es aplicar la siguiente estrategia para la
escritura:

* Ubicarse en la parte de la tesis a escribir, esto consiste llevar el cursor
a ese punto y preguntarse ¿qué va aquí? Dependiendo de la respuesta hacer un
mini-plan de cuales son los puntos importantes y como recorrer esos puntos. De
preferencia el mini-plan no debe abarcar más de una subsección.
* Una vez ubicados hay que escribir como loco, párrafo tras párrafo,
hasta agotar nuestro mini-plan.
* Una vez terminado un mini-plan hacemos una revisión menor, corrigiendo
errores ortográficos, puntuación, repeticiones, simplificando el lenguaje,
revisamos que las ideas principales estén ahí.
* Una vez terminada la revisión, podemos tomar la decisión de si necesita más
trabajo, o podemos continuar con otra subsección y su mini-plan
correspondiente.
* Una vez que estemos exhaustos de este proceso paramos. Para saber que
estamos exhaustos es fácil, vemos que tanto tiempo estamos pasando en
_Facebook_ ;-) Si es más de lo que escribimos es tiempo de parar.
* En algún momento diferente (después del Facebook :-), volvemos a leer lo que
escribimos y le volvemos poner atención, pero solo corregimos errores menores;
cambios mayores se posponen para otro momento de inspiración.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">La introducción</title>
    <id>como_escribir_la_tesis_intro</id>
    <updated>2014-08-21T00:00:00Z</updated>
    <published>2014-08-21T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_intro" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">

Como dijimos en el post de las [partes de la
tesis](/#/post/como_escribir_la_tesis_organizacion),
la introducción es la parte más difícil de escribir. Algunos aspectos que la
hacen difícil son:

* La introducción presenta al trabajo en su totalidad, pero no podemos
recurrir al detalle porque no se le ha presentado al lector los elementos
básicos.
* Es un capítulo corto, el objetivo no es explicar sino motivar el problema y
presentar de manera intuitiva nuestra propuesta para solucionarlo.
* Es un capítulo argumentativo, no es muy formal lleno de explicaciones o
código o formulas, sino que en lugar usa argumentos para presentar nuestro
tema.

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/baby_intro.jpg'
title=&quot;Introducción de la tesis&quot;/&gt;
&lt;/center&gt;

Partes de la introducción
=========================

A pesar de los aspectos que hacen difícil escribir la introducción ésta
tienen algunas secciones que restringen, enfocan y facilitan su escritura.

Introducción de la introducción
-------------------------------

Este generalmente son los primeros párrafos y la intensión es ubicar
rápidamente al lector en el tema que aborda el trabajo, la solución que
exploramos y a dónde pretendemos llegar.

Motivación
----------

Esta sección presenta el por qué trabajar nuestro problema es importante.
En la motivación se puede especular un poco sobre el impacto que tendrían
resultado positivos de nuestra investigación en nuestra área y
consecutivamente en el mundo.  La intensión es hacer saber al lector porque
debemos poner atención al problema y porque la solución que se propone es
interesante.

Objetivos
---------

Esta sección es muy corta y enumera los objetivos del trabajo. Generalmente,
hay un objetivo principal que es el problema que queremos resolver usando
nuestra propuesta. A este objetivo se le conoce como *objetivo general*.
Satelital a este objetivo existen otros que denominamos como *objetivos
especificos*, algunas veces tienen que ver con recolectar información,
modificar algo para aplicarlo a nuestro problema o demostrar algunos aspectos
menores del problema.

Metas
-----

Las metas muchas veces están relacionadas con los objetivos específicos, sin
embargo existe una diferencia procedural. Las metas representa las etapas que
tiene que pasar tu investigación para alcanzar el objetivo general. Por
ejemplo, una meta asociada a un objetivo especifico puede ser:

* Recolectar y etiquetar una base de datos de ejemplos

El objetivo específico sería:

* Crear base de datos de ejemplos

Mientras que el primero está orientado a qué se hace, el segundo esta
orientado a qué se obtiene.

Hipótesis
---------

Las hipótesis son raramente puestas de manera explicita en una tesis de
computación, pero algunos formatos de tesis lo requiere. Pero dado que ya
sabemos el tema, el problema y tenemos una propuesta, hacer una hipótesis es
muy sencillo. Simplemente reformulamos estos aspectos en términos de una
suposición que nuestro problema e evidencia generaran.

Estructura de la tesis
----------------------

Esta sección literalmente lista de que tratarán los capítulos que compondrán
nuestra tesis. Algo común es ligar los elementos hasta este momento
presentados y los capítulos donde se abordarán.


Estrategia
==========

Mi recomendación para este capítulo es escribirlo en dos pasadas:

* La primera pasada se hace al inicio de la escritura de la tesis y de ser
posible a inició de la investigación. Recomiendo que se haga de manera muy
positiva, pensando que se alcahazará todo lo que nos proponemos. Es importante
que ésta se escriba de forma rápida. No se debe invertir mucho tiempo a que
esté perfecta en términos del lenguaje e ideas, ya que será ampliamente
editada en la siguiente pasada.
* La segunda pasada se hace al final en conjunto con las conclusiones. En este
momento revisamos nuestra introducción y moderamos el alcance de ésta dado los
resultados y objetivos alcanzados. En esta segunda pasada ponemos mayor
atención al lenguaje y formato, todo esto con honestidad del trabajo hecho en
nuestra investigación.

Otra recomendación que me gusta hacer, es pensar de lo general a lo
específico. Presentar de manera general dónde está localizado nuestro problema
y rápidamente llevar al lector a lo especifico de como lo pretendemos
resolver.

En este capítulo también podemos acudir a la intuición del lector y utilizarla
en nuestro favor para guiarlo en nuestra propuesta. El uso de analogías y
ejemplos es altamente recomendado con este fin.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Las partes de la tesis</title>
    <id>como_escribir_la_tesis_organizacion</id>
    <updated>2014-08-20T00:00:00Z</updated>
    <published>2014-08-20T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_organizacion" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">
La estructura de una tesis en computación y en particular en aprendizaje
automático está muy estandarizada. Estas son algunas partes comúnes en una
tesis en este campo:

* Introducción
* Trabajo anterior/Revisión de la literatura/Estado del arte
* Metodología
* Corpus o bases de datos usados
* Experimentos y resultados
* Conclusiones
* Apéndices

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/tesis_flow.jpg'
title=&quot;Organización de la tesis&quot;/&gt;
&lt;/center&gt;



Introducción
============

Esta parte generalmente es capítulo inicial y en el que se presenta al trabajo
en términos de qué se trata, qué problema se resuelve, la motivación de
resover dicho problema y cual es la idea principal para resolverlo. Este es
sin lugar a dudas el capítulo más difícil de escribir, dado que se tiene que
hablar de todo pero sin recurrir a mucho detalle ya que este capítulo está
dirigido a cualquier persona que tenga interés en nuestro trabajo pero no es
necesario que sea experto en el tema.  Nuestro objetivo es que el lector sepa
cual es el punto inicial, el final y cual es el camino a recorrer, pero
también tenemos que explicar por qué es un camino interesante a estudiar. Este
capítulo no pretende convencer que esta es una buena forma de recorrer el
camino, pero si que dar una idea de que es razonable, la evidencia sobre la
validez de nuestro trabajo será presentada en el resto de los capítulos
posteriores.


Trabajo anterior
================

Esta parte generalmente es el segundo capítulo y en él se presenta un resumen
del trabajo relacionado a nuestra tesis. No tenemos que hablar de todo el
trabajo anterior sino sólo debemos incluir trabajos en los que se basa nuestra
solución o trabajos que presentan soluciones alternativas a nuestro problema.
Este conocimiento que es relevante a nuestro trabajo lo denominamos como
*estado del arte*. El capítulo es muy conciso, pero no es una lista, tienen
que hilarse los trabajos y demostrarse que tenemos un conocimiento pleno de
éstos.  Podemos imaginarnos que estamos describiendo un mapa en dónde están
localizados estos trabajos y las relaciones que guardan entre sí.
Adicionalmente, deseamos que quede claro donde quedará ubicado nuestro trabajo
en comparación al resto.  En este capítulo se tiene que ser muy honesto pero
crítico sobre lo que proponen los otros trabajos.

Metodología
===========

Esta parte en realidad pueden ser uno o más capítulos. Si nuestro trabajo se
basa en alguna metodología establecida, agregamos un capítulo que hable a
detalle de esta metodología. Lo recomendable en este caso es que el capítulo
sea didáctico, como si se tratara de notas para una clase la esta metodología.
El uso de ejemplos es muy recomendado, una estrategia es tomar un ejemplo
sencillo e irlo construyendo durante el capítulo.  Al terminar el lector debe
tener una idea clara de los elementos que compone la metodología y porque esta
metodología es solida. Esto último no se hace justificando la metodología,
sino explicándola y citando la evidencia que la respaldan (artículos, sistemas
equivalentes, etc).

El siguiente o los siguientes capítulos explican las adecuaciones o uso de la
metodología para nuestro problema particular o si es una nueva metodología la
explican a detalle. En este caso si es importante justificar y demostrar que
los puntos de decisión que tomamos son razonables y bajo nuestras suposiciones
son adecuados. Por ende este capítulo es más argumentativo y riguroso. Podemos
seguir una estrategia didáctica, o describir nuestra posición de forma formal.

Corpus
======

Si tu tesis es en aprendizaje automático, muy probablemente uses una base de
datos, corpus o colección para demostrar tu metodología. Para describir esta
se puede usar el espacio de un capítulo, o se puede incluir en forma de una
sección en alguno de los capítulos de trabajo anterior, de metodología o como
parte del siguiente capítulo. Todas las opciones son posibles, y dependerá del
hilo de  tu tesis que opción es adecuada. La descripción tiene que ser concisa
estilo reporte, hay que describir el recurso y por qué es adecuado para tu
trabajo.  Estadísticas sobre el recurso ayudan a dar una imagen más completa
sobre éste.

Experimentos
============

Este parte es muy importante, primero hay que describir en general los
experimentos a realizar y porque son adecuados para tu trabajo, sobretodo
porque los posibles resultados apoyan la solución propuesta. Uno puede escoger
dos formas de presentar experimentos y resultados. La primera opción es
separar todas las descripciones de los experimentos de los resultados, esto
hace muy fácil a la luz de los resultados hablar de forma general como estos
resultados apoyan a las conclusiones principales pero dificulta lectura ya que
experimento y resultado no están inmediatos. La segunda opción, es
intercalarlos cada experimento propuesto está seguido de sus resultados, esto
facilita la lectura, pero requiere que haya una sección especifica para
recapitular los resultados y describir el efecto de estos en su conjunto en
alcanzar las conclusiones del trabajo.  Lo deseable es que el lector al
finalizar este capítulo tenga una idea clara de que experimentos se hicieron,
como se relacionan entre si y como los resultados contribuyen a entender la
solución propuesta.

En trabajos muy extensos es posible separar este capítulo en dos: experimentos
y resultados; o aún más si hay una evolución de los experimentos.

Conclusiones
============

Está es la última parte de la tesis, y se presenta como un capítulo que
recapitula los puntos más importante de la tesis. Retoma los puntos descritos
en la introducción y lo relaciona con los resultados de tal forma que
argumenta como estos últimos apoyan a determinar que nuestra solución al
problema fue adecuada. Una vez hecho esta recapitulación podemos discutir cual
es el impacto del nuevo conocimiento que generamos y a partir de esta que
otras investigaciones podríamos hacer. En resumen este capítulo es concreto
cuando hablamos del trabajo hecho, y especulativo cuando mencionamos el
trabajo futuro (para más detalle revisa [este post](/#/post/como_escribir_la_tesis_conclusion)


Apéndices
=========

Aspectos muy específicos de nuestro trabajo pueden incluirse como apéndices.
Estos representa detalle que contribuye a la validez de nuestros argumentos,
pero que son muy tediosos para su lectura en el cuerpo principal de la tesis.
Algunos aspectos comunes que se incluyen como apéndices son:

* Código
* Deducciones matemáticas
* Figuras o esquemas muy detallados como mapas


Partes extras
=============

Además de las partes anteriores es común incluir:

* Una portada con los datos de título, nombre de autor, institución y otros
aspectos formales.
* Un indice de los capítulos, secciones y subsecciones de la tesis
* Un indice de las figuras y tablas
* Una hoja con una dedicatoria
* Una hoja con un agradecimientos
* Un resumen corto de la tesis


Longitud de la tesis
====================

Una tesis generalmente está arriba de 50 cuartillas en su totalidad, en
cómputo las tesis son algo extensas llegando hasta más de cien hojas. La
introducción es corta en el sentido que se extiende de 4 a 8 cuartillas. La
conclusiones pueden ser todavía más cortas o más extensas dependiendo si se
hace una discusión a detalle, de 2 a 10 cuartillas. El resto de los capítulos
son de alrededor de 10 a 25 cuartillas.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">LaTeX or not LaTeX</title>
    <id>como_escribir_la_tesis_latex</id>
    <updated>2014-08-19T00:00:00Z</updated>
    <published>2014-08-19T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_latex" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
Decidir el tipo de formato de tu tesis tiene un efecto directo y duradero en
la forma en que trabajarás durante la escritura de ésta. Mi consejo siempre
es:

* Escribir la tesis con las herramientas que estés acostumbrado a escribir
documentos: Word, libre office, block de notas... (esta última en broma ;-).

Sin embargo, yendo en contra de mi consejo es buena idea, al menos por el
transcurso de este post, considerar escribir/programar la tesis usando
[LaTeX](http://en.wikibooks.org/wiki/LaTeX) (Latex de aquí en adelante.) Latex
es un lenguaje  *markup*, es decir a través de marcas en el texto definimos el
contenido y el formato del documento. Ejemplos de lenguajes *markup* son:
HTML, Markdown, XML, etc.  En particular Latex es muy popular entre la gente
de computo para crear documentos, no solo porque es programático sino porque
realmente los documentos generados quedan bonitos.

&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/philosoraptor.jpg'
title=&quot;Respalda ante todo&quot;/&gt;
&lt;/center&gt;



Archivos fuente
===============

Literalmente nuestro documento está contenido en uno o varios archivos fuente
como si fuera un programa.  Por usos y costumbres estos documentos tienen la
extensión *.tex*. Dentro de ellos escribimos el texto y las marcas que definan
las partes y secciones de nuestro documento. Un archivo muy básico en Latex
luce de la siguiente forma:

``` tex
\documentclass[11pt,spanish]{report}
\usepackage[spanish,mexico]{babel}
\usepackage[utf8]{inputenc}

\begin{document}

\title{Estructura básica de una tesis}
\author{Ivan Vladimir Meza Ruiz\\
IIMAS-UNAM}
\date{19 de septiembre de 2014}

\maketitle

\tableofcontents

\chapter{Este es un capítulo}

Este es el contenido de mi tesis.

\section{Esta es una sección}

Aquí va más contenido dentro de una sección.

\subsection{Esta es una subsección}

Este sigue siendo contenido muy especifico dentro de una subsección.

\appendix

\chapter{Este es un apéndice}

Este el contenido de la tesis

\end{document}
```

La línea 1 define el formato general del texto, fuente base y estilo reporte.
Las siguientes dos líneas cargan librerías, existen muchísimas de estas, que
agregan opciones a nuestro texto o controlan ciertos aspectos de la
generación.  Estas dos librerías permiten escribir documentos en español y que
aparezcan lo mejor posible. En la línea 5 empezamos propiamente el documento.
Entre línea 7 y 9 se definen parámetros que son utilizados cuando se genera la
portada con la instrucción en la línea 12. La línea 14 genera el índice de
nuestro documento. Finalmente en la línea 16 comenzamos a escribir el
contenido del documento. Latex tiene múltiples instrucciones para organizar
nuestro contenido, aquí vemos *chapter*, *section* y *subsection*.  En la
línea 26 cambiamos la naturaleza de esos comandos indicándole que a partir de
ahora se trata de apéndices, finalmente la linea 34 termina nuestro documento.

[//] # (El documento fuente y generado usando el comando _pdflatex_ si encuentran
aquí:

* [Documento fuente]({{url_for('static',filename=&quot;files/latex_basico.tex&quot;)}})
* [PDF generado]({{url_for('static',filename=&quot;files/latex_basico.pdf&quot;)}})
)


Actualmente existen varias liberias y recursos para que la tesis sea en el
formato adecuado de varias facultades y universidades:

* [Facultad de Ciencias-UNAM](http://tezcatl.fciencias.unam.mx/latex/)
* [Facultad de Ingeniería-UNAM](https://github.com/Tepexic/Tesis-FI-UNAM)
* [UNAM](http://www.ctan.org/tex-archive/macros/latex/contrib/unamthesis)
* [UAM](http://mcyti.izt.uam.mx/index.php/guias-y-templetes-)
* [IPN](http://www.upiita.ipn.mx/index.php/descargas/category/28-latex)

La curva de aprendizaje de Latex es bastante empinada y puede llevarte un buen
rato acostumbrarte al ciclo de: edición y compilación. Para tener una idea de
las instrucciones disponibles recomendamos que veas el wikibook:

* [Latex](http://en.wikibooks.org/wiki/LaTeX)

Donde se muestran entre otras cosas:

* Como incluir figuras.
* Como crear tablas.
* Como citar e incluir las referencias.
* Como formatear el texto.
* Como incluir hyperligas.
* Como hacer referencias a partes del documento.
* Como incluir: algoritmos, código y fórmulas.

El editor
=========

Un aspecto que puede facilitar el uso y la programación de tu texto usando
Latex es utilizar un editor adecuado. Muchos editores e IDEs de programación
incluyen extensiones para Latex. De los más comunes en ambiente Linux son:

* Vim
* Emacs
* Eclipse

Para Windows existen [múltiples
soluciones](https://www.google.com/search?q=latex+editor+windows). Además de
soluciones en línea como: [ShareLatex](https://www.sharelatex.com/).

Ante esta situación regreso a mi recomendación original:

* Escribir la tesis con las herramientas que estés acostumbrado a *programar*
;-)

</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">¿Dónde quedo mi tesis, dude?</title>
    <id>como_escribir_la_tesis_backup</id>
    <updated>2014-08-17T00:00:00Z</updated>
    <published>2014-08-17T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis_backup" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
&lt;center&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/keep-calm-and-backup-the-files.png'
title=&quot;Respalda ante todo&quot;/&gt;
&lt;/center&gt;

La tesis es un documento extenso, de mínimo de cincuenta páginas, por lo que
su perdida puede ser una tragedia mayor. Pero dadas las herramientas
disponibles hoy en día, no debe ser el caso, ya que tener respaldos
automáticos y guardar versiones de forma automática no es nada difícil, y te
puede salvar de un susto mayor.

Respaldos
---------

Dependiendo de la plataforma que utilices puedes pedir que se respalde tu
información de forma automática
([Windows](http://windows.microsoft.com/en-us/windows/back-up-files#1TC=windows-7)
o [Linux](https://wiki.gnome.org/Apps/DejaDup)).  Un respaldo de tu tesis
local es importante en caso de accidentes menores, pero  en caso de que tu
sistema falle... un respaldo en otra máquina se vuelve esencial.
Afortunadamente, servicios para compartir archivos en la &quot;nube&quot; hacen este
proceso muy fácil.  Algunas alternativas son:

* [Dropbox](https://www.dropbox.com/)
* [Google drive](https://drive.google.com/)
* [OneDrive](https://onedrive.live.com/about/en-us/)
* [Box](https://www.box.com/)
* [Copy](https://www.copy.com/home/)
* [SpiderOak](https://spideroak.com/)

Versiones
---------

Además de tener una copia de respaldo de tu tesis, es esencial tener el
historial de versiones de esta. Ya que muchas veces hacemos cambios en ella
para luego cambiar de opinión y tenemos deseamos regresar a una  versiones
previa. Una opción, es guardar versiones de forma  manual, pero
afortunadamente editores como Word y Libre Office llevan este control por
nosotros y es fácil regresar a versiones anteriores.

La mayoría de los servicios en la &quot;nube&quot; también también incluyen manejo de
versiones. Basta con buscar en google para encontrar la forma de acceder a
versiones anteriores de nuestros documentos respaldados.

Otra opción muy ad hoc en el aspecto computación es usar un sistema de control
de versiones como lo son: [subversion](http://subversion.apache.org/) o
[git](http://git-scm.com/), para llevar el control de versiones de nuestros
documentos. Esta opción funciona muy bien si está escrita en algún _markup
language_ o en
[LaTex](/#/post/como_escribir_la_tesis_latex)
donde los cambios son muy locales en nuestros archivos _fuente_.

Resumen
-------

¡Siempre, pero siempre, respalda y ten acceso a versiones anteriores de tu
tesis!</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Como escribir una tesis... (en computación)</title>
    <id>como_escribir_la_tesis</id>
    <updated>2014-08-16T00:00:00Z</updated>
    <published>2014-08-16T00:00:00Z</published>
    <link href="/#/post/como_escribir_la_tesis" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
Una tesis es un reporte en extenso y formal en algún tema investigado. Aunque
la investigación es sin lugar a dudas la parte más importante del proceso,
escribir la tesis y crear un buen reporte es esencial para culminar con el
ciclo y así compartir las experiencias, resultados y conclusiones alcanzadas.

Si nunca has visto una tesis te recomiendo hojear algunas. Puedes localizar
tesis en el intenet usando un buscador. O si gustas puedes usar en el catálogo
de la [UNAM](http://tesis.unam.mx/). Los formatos, estilos y lenguaje cambian
mucho dependiendo del área, por lo que la recomendación es que busques una
tesis en el área de tu interés para que te des una idea de como lucen. En esta
serie de posts nos enfocaremos a tesis de computación y principalmente en el
área de aprendizaje automático y robótica, pero algunos de los consejos se
pueden extrapolar a otras áreas y campos de estudios.

Algunos ejemplos de tesis en esta área las puedes encontrar aquí:

* [Tesis que he dirigido](/#/Theses)
* [Tesis en el grupo Golem, buscar sección
Tesis](http://golem.iimas.unam.mx/publications.php?lang=es&amp;sec=publications&amp;order=topic)

Esta serie de posts esta compuesto por las siguientes entradas:

* [¿Dónde quedo mi tesis,
dude?](/#/post/como_escribir_la_tesis_backup)
* [LaTex or not
LaTex](/#/post/como_escribir_la_tesis_latex)
* [Las partes de la
tesis](/#/post/como_escribir_la_tesis_organizacion)
* [La
introducción](/#/post/como_escribir_la_tesis_intro)
* [El lenguaje en la
tesis](/#/post/como_escribir_la_tesis_lenguaje)
* [Figuras, tablas y
referencias](/#/post/como_escribir_la_tesis_figs_refs_etc)
* [El ritual de
escribir](/#/post/como_escribir_la_tesis_ritual)
* [Correcciones y
lecturas](/#/post/como_escribir_la_tesis_correcciones)
* [La
conclusión](/#/post/como_escribir_la_tesis_conclusion)
* [Actividades
extra](/#/post/como_escribir_la_tesis_extra)</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Git y GitHub básico</title>
    <id>git_basico</id>
    <updated>2014-06-30T00:00:00Z</updated>
    <published>2014-06-30T00:00:00Z</published>
    <link href="/#/post/git_basico" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">

[Git](http://git-scm.com/) es un sistema de control de versiones sumamente
poderoso, ees una de las herramientas básicas que un buen programador debe
usar, y para mi es sin lugar a dudas uno de los aspectos que hacen a un
excelente programador.

_Git_ es una herramienta que nos ayuda a tener un registro de las diferentes
versiones de nuestro código. Pero además hace muy fácil y transparente
compartir nuestros proyectos y de paso respaldarlos.Y en especial con
servicios como [GitHub](www.github.com) ha hecho de programar y compartir algo
universal. En este tutorial vamos a ver como usar _git_ en conjunto como
_GitHub_

Instalando _Git_ en Linux
=========================

Solo hay que ejecutar

``` bash
sudo apt-get install git
```

Y listo!

Instalando _Git_ en windows
==========================


Versión original _git_
----------------------

Uno puede instalar  _git__ bajándola de este link:

* [_Git_ para windows](http://git-scm.com/download/win)

Simplemente uno lo baja y sigue las instrucciones en pantalla (con escoger las
opciones por _default_ es suficiente).

Esta versión ofrece una interfaz un poco limitada y algo confusa (_Git GUI_),
o una interfaz de línea de comandos (_Git bash_).  Pero uno puede bajar
diferentes versiones gráficas para mejorar la experiencia:

* [GUIs para _Git_](http://git-scm.com/download/win)

Usando _Git_ con _GitHub_
==========

El ciclo normal de _git_ para trabajar con un proyecto establecido en _GitHub_
es:

* Clonar el proyecto (_clone_)
* Hacer modificaciones en código
* Empacar las modificaciones (_commit_)
* Actualizar el código (_pull_)
* Compartir dichas modificaciones (_push_)


Clonar un proyecto
------------------

Para clonar un proyecto y por lo tanto tener su código fuente (más toda la
historia de versiones) solo falta ejecutar el siguiente comando:

``` bash
git clone URL
```

La URL puede ser obtenida de un proyecto en particular. Por ejemplo, estos son
los proyectos que tengo:

* https://github.com/ivanvladimir

En cualquier de estos pueden entrar, y conseguir la dirección en la parte que
dice &quot;*HTTP* clone URL&quot;. Por ejemplo para mi proyecto sobre el curso de
aprendizaje automático esta dirección es:

* https://github.com/ivanvladimir/cursoML.git

Una vez terminada la clonación, aparecerá un directorio _cursoML_ en donde
está el código clonado.

Para explorar los proyectos hospedados en _GitHub_ puedes visitar el siguiente
link:

* [Proyectos en GitHub](https://github.com/explore)

Hacer modificaciones
--------------------

Uno puede modificar el código como uno desee. Para estar atento de las
modificaciones que uno ha hecho, uno puede ejecutar el siguiente comando:

``` bash
git status
```

Si uno desea agregar un nuevo archivo al control de versiones, uno puede
ejecutar el siguiente comando:

``` bash
git add path
```

Esto agregará el archivo que refiere _path_ y empezará a seguirlo para
mantener el historial de cambios en ellos.

Empacar modificaciones
----------------------

Una vez que tiene al código en un estado con el que uno está contento, éste se
puede empacar con el siguiente comando:

``` bash
git commit -m MENSAJE path
```

_Mensaje_ es un comentario sobre que significa estos cambios, y _path_ es el
código del que queremos empacar nuestras últimas modificaciones. Si uno
modificó muchos archivos puede usar la opción _-a_ y evitar el _path_ para
empacar automáticamente todos los archivos recientemente modificados.

``` bash
git commit -am MENSAJE
```


Actualizar nuestro proyecto
---------------------------

Mientras nosotros hacemos cambios puede haber una nueva versión de los
archivos hecha por algún colaborador.  Para actualizar nuestro proyecto ante
estas nuevas versiones podemos ejecutar el siguiente comando:

``` bash
git pull
```

Esto actualizará nuestro proyecto de la dirección que clonamos.


Compartir nuestra modificaciones
--------------------------------

Hasta ahora las modificaciones que nosotros hemos hecho al código son locales,
pero si necesitamos compartirla con alguien más podemos actualizar el código
del proyecto clonado usando la siguiente instrucción:

``` bash
git push
```

Nada más hay que tener en cuenta que uno tiene que tener las credenciales
adecuadas para que sea esto posible. En _github_ esto significa tener una
cuenta y ser _contribuidor_.

Independizando el código en GitHub
----------------------------------

Si uno no quiere pasar por el código original o simplemente quiere tener
independencia creativa en el proyecto. Uno puede hacer un _fork_ del código.
Esto le permite crear una copia del proyecto pero bajo nuestra
responsabilidad.  En _github_ esto consiste en oprimir el ícono de _fork_ en
el sitio del proyecto que queremos. Después de esto podemos clonar el proyecto
con la dirección asociada a nuestro usuario, y listo!

Creando nuestro propio proyecto
-------------------------------

Por supuesto, uno no tiene que partir de un proyecto, y puede comenzar de uno
vacío. Para crear un archivo y asociarlo a _GitHub_ uno puede usar la opción
en la página:

* [Crear un nuevo proyecto](https://github.com/new)

Uno llena los datos y escoge las opciones, y después ejecuta las siguiente
opciones:

``` bash
touch README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin URL
git push -u origin master
```

Material extra
==============

* [Documentación GitHub](https://help.github.com/)
* [Guía para
principiantes](http://stackoverflow.com/questions/315911/git-for-beginners-the-definitive-practical-guide)
* [Forking en github](https://help.github.com/articles/fork-a-repo)





</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Instalando Python</title>
    <id>como_instalar_python</id>
    <updated>2014-06-20T00:00:00Z</updated>
    <published>2014-06-20T00:00:00Z</published>
    <link href="/#/post/como_instalar_python" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">

[Python](https://www.python.org/) es un lenguaje de programación sumamente
versátil. Instalarlo es muy sencillo.

Actualmente existen dos versiones del lenguaje: 2 (2.7) y 3 (3.4). Las dos son
muy parecidas pero son fundamentalmente diferentes, por lo que hay que estar
seguros que queremos instalar.


En Ubuntu (Linux)
=================

Python generalmente viene pre-instalado y lo único que hay que hacer es
echarlo andar, con el comando _python_

``` python
Python 2.7.4 (default, Sep 26 2013, 03:20:26) [GCC 4.7.3] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
```

Para echar andar la versión 3 solo basta ejecutar el comando _python3_

```
$ python3
Python 3.3.1 (default, Sep 25 2013, 19:29:01) [GCC 4.7.3] on linux
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
```

En Windows
==========

Hay dos formas de instalar python en Windows: instalar la distribución
estándar o una distribución que incluya librerías complementarias.

Estándar
--------

Ir a la página de distribuciones de python y escoger la mejor opción

* [Versiones 2.7 para
windows](https://www.python.org/download/releases/2.7.7/)
* [Versiones 3.3 para
windows](https://www.python.org/downloads/release/python-341/)

Distribuciones con librerías complementarias
--------------------------------------------

Para Windows existen varias distribuciones en estas condiciones, una que
recomendamos por la paquetería científica es:

* [Enthought Canopy](https://store.enthought.com/), bajar la versión gratuira
del sitio y ejecutar el _.exe_ y seguir las instrucciones en la pantalla.  Si
eres estudiante o académico, también existe la posibilidad de solicitar una
versión académica (sólo hay que registrarse).

Una vez instalado, anaconda proporciona una terminal para ejecutar Python
(buscar _anaconda command_) y ejecutarlo. Una vez abierta la terminal,
ejecutar _python_

``` bash
$ python
Enthough Canopy Python 2.7.9 | 64-bit | (defult, May 21 2015, 03:59:03) [MSC v.1500 64 bit (AMD64) on win 32]
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information
```


Otras implementaciones de Python
================================

Las instrucciones anteriores se tratan de la versión principal de python
programada en &quot;C&quot;, también conocida como CPython. También existen muchas
alternativas, de las más famosas:

* [Jython](http://www.jython.org/) implementación de Python en Java
* [PyPy](http://pypy.org/) implementacion de Python en Python
* [pyjs](http://pyjs.org/) compilador de Python a Javascript
* [IronPython](http://ironpython.net/) implementación de Python para .NET

Editores para python
====================

En _linux_ existen varios editores pre-instalados:

* Para línea de comando: [_nano__](http://www.nano-editor.org/),
* [_emacs_](https://www.gnu.org/software/emacs/), [_vim_](http://www.vim.org/)
* Gráficos: [_gedit_](https://wiki.gnome.org/Apps/Gedit).

Los primeros son editores muy profesionales que tienen varias funciones
avanzadas, en particular me permito recomendar _vim_
([aquí](http://vimcasts.org/episodes/ultisnips-python-interpolation/) pueden
apreciar algunas de sus capacidades).  Los segundos proporcionan una
interacción más natural a la que estamos acostumbrado en un ambiente de
ventanas. Uno tiene que escoger uno y familiarizarse con él.

En particular varios alumnos me han recomendado
[_sublime_](http://www.sublimetext.com/) el cual se tiene que instalar, pero
está disponible para diferentes plataformas. Otro popular es
[_PyCharm_](https://www.jetbrains.com/pycharm/)

En _windows_ hay diferentes editores para código, varios de los anteriores
tienen sus versiones para windows. Hay que notar que son muy diferetnes a los
editores de texto y hay que tener cuidado.


Material extra
==============

Ahora que ya tienes instalado Python, puedes continuar aprendiendo sobre él

* [Lista de
tutoriales](https://wiki.python.org/moin/BeginnersGuide/Programmers)
* [Tutoriales en español](https://wiki.python.org/moin/SpanishLanguage)
* [Preguntas frecuentes de python](https://docs.python.org/3/faq/)
* [Lista de libros](https://wiki.python.org/moin/IntroductoryBooks)
* [Ejemplos de código](https://wiki.python.org/moin/BeginnersGuide/Examples)
* [IDEs para
programar](https://wiki.python.org/moin/IntegratedDevelopmentEnvironments)
* [Listas de distribuciones de
Python](https://wiki.python.org/moin/PythonDistributions)
* [Lista de implementaciones de
Python](https://wiki.python.org/moin/PythonImplementations)
* [Editores de texto para python](https://wiki.python.org/moin/PythonEditors)
* [IDE para
python](http://stackoverflow.com/questions/81584/what-ide-to-use-for-python)
* [Comunidad Reddit de python](http://www.reddit.com/r/Python/)
* [Sobre que versión escoger](https://wiki.python.org/moin/Python2orPython3)
* [Instalarlo en Mac](https://www.python.org/downloads/mac-osx/)
* [Otra opción científica: Anaconda](http://continuum.io/downloads)</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Como leer un artículo científico... (en computación... en aprendizaje automático :-)</title>
    <id>como_leer_un_articulo</id>
    <updated>2014-06-19T00:00:00Z</updated>
    <published>2014-06-19T00:00:00Z</published>
    <link href="/#/post/como_leer_un_articulo" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
La actividad científica continuamente está generando conocimiento que redefine
lo que sabemos sobre todos los aspectos de nuestra existencia. Un artículo
científico registra de forma escrita este nuevo conocimiento con el fin de
diseminarlo entre los expertos del área, de tal forma que ellos puedan
confirmarlo o aún mejor, partiendo de éste generar nuevo conocimiento.  Por lo
anterior, cuando nos interesa saber sobre esa frontera del conocimiento los
artículos científicos son una fuente invaluable.  Sin embargo, leer un
artículo no es fácil y es más bien un habilidad que hay que desarrollar ya que
éstos están dirigidos a expertos del área y su contenido depende de
convenciones del área. A continuación presentamos algunas sugerencias de como
leer un artículo científico, mucha de mi experiencia se centra en computación
y en particular en aprendizaje automático, así que este texto se centra en
estas áreas.

¿Qué es un artículo científico?
-------------------------------

Un artículo es un escrito que argumenta que partiendo de cierto conocimiento y
tomando en cuenta la evidencia que se enumera en el artículo se puede llegar
una nueva veta de conocimiento. Algunos ejemplos de artículos son (una
selección de mis artículos favoritos :-):

- AM Turing. [On computable numbers, with an application to the
Entscheidungsproblem](http://classes.soe.ucsc.edu/cmps210/Winter11/Papers/turing-1936.pdf),Proceedings
of the London Mathematical Society, Ser.  2, Vol. 42, 1937.
- AM Turing. [Computing Machinery and
Intelligence](http://www.jstor.org/stable/2251299), Mind , New Series, Vol.
59, No. 236, 1950.
- L Zettlemoyer and Collins, M. [Online Learning of Relaxed CCG Grammars for
Parsing to Logical
Form](http://homes.cs.washington.edu/~lsz/papers/zc-emnlp07.pdf).  In
Proceedings of the Joint EMNLP-CoNLL, 2007.
- J Wright, Yang, AY, Ganesh A, Sastry SS, Yi Ma. [Robust Face Recognition via
Sparse
Representation](http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4483511&amp;tag=1)
Pattern Analysis and Machine Intelligence, IEEE Transactions on , Vol.31, No.2,
2009

Un artículo comienza siendo un borrador hasta que se publica. Para publicarlo,
el borrador se somete a la comunidad de expertos para su revisión; esto
consiste en asignarlo a un grupo de expertos, tres es algo común, quienes
decidirán si vale la pena exponerlo a un grupo más grande de la comunidad ya en
una versión final y publicada. Esta decisión depende de varios factores como:
la calidad de la argumentación, evidencia; si las conclusiones son razonables;
si es nuevo conocimiento; o si el tema que trata corresponde con la comunidad a
la que se dirige.

Partes de un artículo
=====================

Con el paso del tiempo la estructura de un artículo se ha consolidado. Hoy en
día existen partes muy comunes entre artículos con fines muy específicos. A
continuación una lista de estas partes:

- *Título* Este es el nombre con el que se conocerá el escrito, tiene el
objetivo de describir el trabajo y de atraer la atención a éste.
- *Lista de autores* Esto son los nombres de quienes se les acredita la
creación del escrito y la realización del trabajo descrito en él.
- *Resumen/abstract* Literalmente es un resumen del trabajo.
- *Palabras claves/key words* Esta es una lista de palabras que describen al
trabajo y lo relacionan con otros trabajos.
- *Introducción* Esta generalmente es la primera sección y corresponde al
contexto y la motivación que originan al trabajo.
- *Trabajo anterior* Cuando aparece esta sección se menciona a otros artículos
que se relacionan con este trabajo ya sea porque son la base de éste, o son un
punto de comparación.
- *Metodología/Propuesta* Esta sección no aparece como tal, esta compuesta por
las secciones que describen a detalle las propuestas de este trabajo.
- *Experimentos/resultados* Esta sección es muy común en artículos de
aprendizaje automático. Esta sección describe los experimentos que se hacen y
los resultados que justifican las conclusiones. Esta sección también es muy
especializada y técnica. Generalmente se presentan tablas y gráficas de los
resultados que hay que saber interpretar.
- *Conclusiones/Discusión/Trabajo a futuro* En esta secciones se resaltan las
conclusiones y el razonamiento para llegar a ellas. Muchas veces se discute
sobre los límites y consecuencias de estas, y se lista posibles alterativas
para complementar o continuar con la investigación.
- *Bibliografía* En esta sección se listan los artículos, trabajos y a veces
software al que se hace referencia en el artículo. Esta lista generalmente
sigue un formato muy particular.

Aunque estas partes son muy comunes no son las únicas, y ultimadamente un poco
de creatividad también puede ser factor en la definición de la estructura.
Aunque los artículos generalmente siguen los patrones que la comunidad a la que
se dirige el trabajo identifica como adecuadas.


¿Dónde encuentro un artículo científico?
========================================

Afortunadamente a través del internet se pueden tener acceso a un gran número
de artículos. Existen tres fuentes principales: los publicistas, los autores y
herramientas especializadas.

Los publicistas ponen a disposición los artículos que ellos publican. Estos los
podemos encontrar a través de sus sitios. Algo normal - aunque su validez en el
mundo actual académico está en discusión- es suscribirse a una editorial y
tener acceso a estas colecciones bajo algún costo económico (afortunadamente la
UNAM y otras instituciones cuenta con acceso a varias editoriales, aquí una
lista del
[IIMAS](http://www.iimas.unam.mx/biblio/pagina/es/17/revistas-digitales)). Una
alternativa, son las editoriales de libre acceso, en estas no se requiere
ningún pago por parte del lector, muchas veces los autores son los que pagan
por el costo de publicar (para ejemplos visitar [DOAJ](http://doaj.org/)) --
esta alternativa también ha creado ciertas
[circunstancias](http://www.the-scientist.com/?articles.view/articleNo/32426/title/Predatory-Publishing/).
Otros publicistas como congresos o conferencias tienen repositorios donde los
artículos expuestos pueden obtener también bajo los dos esquemas (ejemplos:
[ACL](http://aclweb.org/anthology/), [NIPS](http://papers.nips.cc/)).  En
particular en aprendizaje automático es en estos repositorios en donde se
encuentra el conocimiento más reciente y relevante del campo.

Otra fuente de acceso a artículos son los autores a través de sus páginas.
Muchas veces ahí se tiene acceso a versiones borrador de la publicación o
ligas directas a donde se encuentran las versiones finales. Por ejemplo pueden
visitar la sección de publicaciones en mi [página](tmp) ;-).

Finalmente, existen herramientas especializadas para la búsqueda de artículos.
En particular el buscador de google hace un buen trabajo identificando
artículos. Pero también existe una herramienta especializadas que indexan los
artículos [Google scholar](http://scholar.google.com/).  Microsoft tiene la
herramienta de [Academics](http://academic.research.microsoft.com/).  Ambas
herramientas permiten explorar trabajos similares ya sea por los autores, las
citas o el tema de éste. Otros índices que permiten esta exploración son
[DBPL](http://www.informatik.uni-trier.de/~ley/db/).

Por supuesto también existen árticulos impresios (cada vez menos), y pudes ir a
una bilioteca especializada para tener acceso a estos. Por ejemplo, la
[biblioteca del IIMAS](http://www.iimas.unam.mx/biblio/).

¿Cómo leo un artículo científico?
=================================

Leer un artículo es una habilidad y depende del objetivo que buscas. Si el
artículo que quieres leer es fundamental para alguna actividad: escribir un
reporte, tesis o reproducir los resultados, hay que prepararse para un esfuerzo
mayor en donde muy probablemente inviertas mucho tiempo en el artículo y tengas
que leer otros trabajos relacionados. Si solo buscas obtener una idea muy
probablemente con el tiempo y entre más artículos leas en el área, podrás
hacerlo de forma concisa. A continuación, nos concentraremos en el primer caso.

Mínimo tres pasadas
------------------

Una estrategia común es darle al artículo tres pasadas (esto nunca ha
funcionado conmigo, generalmente necesito de más de tres pasadas, por eso lo de
mínimo).

Primera pasada
--------------

La primera pasada es una a ojo de pájaro, muy &quot;rápida&quot;. Se recomienda leer las
secciones generales: el título, el resumen, la introducción, identificar las
secciones y las conclusiones. En esta pasada buscamos identificar las ideas
generales del artículo como lo son: de qué trata, que motivación tiene, en qué
trabajo se basa, qué estructura usa para argumentar su caso y qué conclusiones
y contribuciones presentan.


Segunda pasada
--------------

En esta pasada procedemos a leer las secciones donde se presenta el trabajo de
manera específica. En esta pasada se recomienda brincarse las ecuaciones y
gráficas.  La idea es identificar el hilo de la argumentación completa. Para
esto si podemos contestar los aspectos de la primera pasada con certeza podemos
leer únicamente las secciones no leídas hasta ahora. En caso contrario,
conviene leer el cuerpo principal (no resumen) de artículo de principio a fin.
Después de esta lectura debemos poder contestar: qué metodología/técnica
proponen, cuales son los elementos de esta metodología, qué experimentos usan,
qué resultados obtienen, debemos identificar la liga entre los
experimentos-resultados y las conclusiones que presentan.

Tercera pasada
--------------

En esta pasada nos podemos a enfocar a entender los detalles, fórmulas y
gráficas. También podemos ser más críticos y poner a prueba el hilo de la
argumentación.

Siguientes pasadas
------------------

Continuar leyéndolo, a lo mejor enfocándose en ciertas secciones; hasta que
estemos satisfechos con lo que sabemos del artículo.


Sugerencias
-----------

Los artículos muchas veces son repetitivos, en la introducción presentan el
objetivo, en la metodología se explica como se va alcanzar dicho objetivo, en
los experimentos se dice como los resultados se relaciona a los objetivos, y en
las conclusiones se especifica que objetivo se alcanzo. De esta forma el
objetivo se presenta desde varios perspectivas, lo que hace fácil su
identificación si se pone atención.


Algunas estrategias adicionales que podrían ayudar a entender el artículo son:

- Subrayar líneas que contesten a los aspectos señalados en las pasadas.
- Hacer notas mientras se lee el artículo
- Hacer un resumen muy corto sobre el artículo (2-3 oraciones)
- Comparar el artículo con otros trabajos
- Escribir una opinión sobre el artículo


Problemas comunes al leer un artículo
-------------------------------------

Una de las limitantes que tenemos para acceder al conocimiento expuesto en los
artículos es el idioma. Irónicamente, la lengua
[franca](http://en.wikipedia.org/wiki/Lingua_franca#Etymology) de la
investigación es el inglés, por lo que lo tenemos que dominar a nivel de
lectura, sobretodo en el área de computación y aprendizaje automático el inglés
es predominante. Una opción posible es usar alguna herramienta de [traducción
automática](http://translate.google.com/), pero hay que tener en cuenta que no
es perfecta y puede crear confusiones.

Dominar el inglés no es suficiente para entender el lenguaje utilizado en el
artículo. Generalmente el inglés usado en un artículo es especializado y
también hay aprender el lingo de la especialidad. En estos casos la sugerencia
es tener paciencia,  acceso a diccionarios especializados, libros en la
especialidad, cursos en el área, preguntar a expertos, leer tutoríales, leer
otros trabajos, y confiar en el sentido común mientras llenamos todos los
agujeros.


Identificando otros artículos
-----------------------------

Un aspecto importante al leer un artículo es identificar otros trabajos
relacionados. La mayoría de las veces el trabajo relacionado viene listado en
la introducción o la sección de trabajo anterior. Los trabajos ahí mencionados
son de dos tipos, los que son una base para el trabajo presente y trabajos
alternativos que sirven de punto de comparación.  Dependiendo del objetivo, si
buscamos entender más este articulo, nos conviene leer sobre las bases, pero si
buscamos entender más sobre el área y la contribución, nos conviene leer más
sobre los trabajos alternativos.

Estos trabajos serán citados en el artículo y la información completa para
identificarlos viene en la sección de bibliografía. Un buen punto para
localizar el trabajo es usar una de las herramientas mencionadas antes. Muchas
veces,  con poner el título en Google es suficiente para encontrar alguna pista
de donde localizar este recurso.

Otra forma de localizar material relacionado, es ir a la páginas personales de
los autores y a sus  publicaciones y tratar de identificar si hay una serie de
publicaciones relacionadas con el tema.

Palabras finales
----------------

Por supuesto el éxito de leer un artículo científico no depende de seguir esta
estrategia al pie de la letra, sino de concentrarse en la tarea módulo el
objetivo que se persigue. Muy probablemente, lees este documento porque estas
comenzando una investigación y de seguro estás en el contexto de un grupo de
investigación, por lo que también te recomendamos platicar con tus colegas y
supervisores sobre el tema y la mejor forma de entender el artículo.

---
Referencias

&lt;a id=&quot;referencias&quot;&gt;&lt;/a&gt;

* [How to Read a
Paper](http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/data/07/paper-reading.pdf)
* [How to Read a Research
Paper](http://www.eecs.harvard.edu/~michaelm/postscripts/ReadPaper.pdf)
* [How to Read a Paper: The Basics of Evidence-Based
Medicine](http://www.amazon.com/How-Read-Paper-Evidence-Based-Medicine/dp/1444334360)
* [How to Read a Scientific
Paper](http://www.biochem.arizona.edu/classes/bioc568/papers.htm)
* [How to Read an Engineering Research
Paper](http://cseweb.ucsd.edu/~wgg/CSE210/howtoread.html)
* [Efficient Reading of Papers in Science and
Technology](http://www.cs.columbia.edu/~hgs/netbib/efficientReading.pdf)
* [The Researchers bible](http://www.cs.duke.edu/~chase/cps300/resbible.pdf)
* [How to Read and
Article](http://www.lenmholmes.org.uk/students/how2read/how2read_a.htm)
* [How to Read an Academic
Article](http://www.lenmholmes.org.uk/students/how2read/how2read_a.htm)
* [How to read a scientific
article](http://www2.fiu.edu/~collinsl/Article%20reading%20tips.htm)
* [Reading a Journal Article Critically and
Effectively](http://tep.uoregon.edu/resources/exchange/research/readingjournalarticles.html)
* [How to read a research
paper](http://ccc.inaoep.mx/~esucar/Clases-semdr/Lecturas/reading.pdf)</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Distancias en texto</title>
    <id>intro_distancias_texto</id>
    <updated>2013-09-11T00:00:00Z</updated>
    <published>2013-09-11T00:00:00Z</published>
    <link href="/#/post/intro_distancias_texto" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
Para entrar en ambiente comenzamos con
[Cake](http://en.wikipedia.org/wiki/Cake_(band)) y su éxito &quot;The Distance&quot; ;-)


&lt;center&gt;
&lt;iframe width=&quot;640&quot; height=&quot;480&quot; src=&quot;//www.youtube.com/embed/F_HoMkkRHv8&quot;
frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;
&lt;/center&gt;

Ya ambientados proseguimos. Para cuantificar que tan cerca o lejos están dos
puntos usamos el concepto de distancia. En la vida cotidiana usamos distancias
sin detenernos a pensar mucho en ello, por ejemplo:

* La distancia entre las esquinas en un lado de una cancha de fútbol
internacional es entre 100-110 m.
* La distancia de la [UNAM](http://www.unam.mx) al centro histórico de la
Ciudad de México según el [Google Maps][unamch] es de 21.3km.
* La distancia de un maratón es de 42.195 km.
* La [distancia][tijuanatapachula] de Tijuana, una de las ciudades más al
norte de México, y Tapachula, otra ciudad muy al sur, es aproximadamente
de 3,837km.
* La distancia de la Tierra a la Luna es de  384,400km.
* La distancia del Sol a Neptuno es de 4 mil 500 millones de km.

De esta forma podemos intuir que esos dos banderines en las esquinas de
una cancha de fútbol están muy cerca en comparación de la UNAM al Centro
Histórico, o aún mucho mucho mucho más cerca que lo que está el Sol de
Neptuno.  Resulta que esa intuición de que dos puntos están cercanos o
lejanos los podemos calcular de distintas formas, sobretodo cuando los
puntos en cuestión son representados en vectores.

Vectores
--------

De manera muy laxa nos podemos imaginar a un vector como una
representación de un conjunto de cajas que solo pueden contener un cierto
tipo de objetos, por ejemplo como un ropero. En lo que estamos interesados
en representar es la cantidad de objetos que hay en cada caja.  Podemos
imaginarnos a un ropero 'muy ordenado' como un vector, si contamos la
cantidad de objetos en cada caja podríamos terminar con el &quot;vector&quot;: pares
de zapatos, 12; corbatas y 6; playeras, 38.

Por supuesto, los vectores son una abstracción y no hacen referencias a
cajas reales y no necesitamos indicar de qué tipo es cada caja. Por
ejemplo, ese ropero lo podemos representar como [12,6,38]. De alguna forma
acordamos que la primera posición son los pares de zapatos, la segunda las
corbatas y las tercera las playeras. Ese orden no lo podemos cambiar entre
vectores que representen lo mismo, roperos en nuestro caso. Un ejemplo de
tipo de vectores muy común es el de coordenadas XY, estos son vectores con
dos componentes.  La primera posición representa la cantidad en X que hay que
avanzar para llegar a un punto, y la segunda posición la cantidad en Y.  De
tal forma que el vector [3,2] dice camina tres metros hacia X y dos hacia Y.

Regresando a nuestro ejemplo del ropero [12,6,38] podríamos decir que es un
ropero de muchas playeras a comparación de [7,5,12] y por lo tanto las
personas a las que perteneces son un tanto diferentes. Pero cuando lo
comparamos con el dueño del ropero [13,5,40] podemos imaginarnos que son
cercanos en algún aspecto.

Lo que vamos a ver a continuación es como representar **documentos de texto**
como vectores y cuantificar que tanto se parecen estos dada la distancia que
los separa, entre más cercanos, más se parecen; entre más lejanos, menos se
parecen.


Representación vectorial de texto
---------------------------------

Para representar a un texto como un vector vamos a contar ciertas
particularidades del texto, esas particularidades etiquetan a las &quot;cajas&quot; de
los vectores. Por ejemplo, algo muy común es contar las palabras de un texto,
cada palabra se convierte en un índice del vector y la cantidad de veces que
aparece esa palabra se le denomina el escalar del vector.

Para ejemplificar esta situación, teclea o pega un texto en el siguiente
cuadro. Una vez que estés listo oprime el botón de *Dibujar vector*, este va a
producir un matriz de las 100 palabras más comunes en el texto, entre más alta
sea su cuenta más brillante el color con que se representa en la celda.

&lt;form name=&quot;texto1&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;&lt;emph&gt;Escribe o pega un texto aquí&lt;emph&gt;&lt;/p&gt;
&lt;textarea  id=&quot;tatexto1&quot; rows=&quot;12&quot;  style=&quot;width: 720px&quot; name=&quot;inputbox&quot;
value=&quot;&quot;&gt;&lt;/textarea&gt;
&lt;p&gt;
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Dibujar vector...&quot;
onClick=&quot;matrixtext(this.form,'#example1','text-example1',250,250,true)&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;center&gt;
&lt;div id=&quot;example1&quot;&gt;&lt;/div&gt;
&lt;div id='small'&gt;
&lt;div id=&quot;text-example1&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/center&gt;


Además de contar las palabras también podemos contar el número de pares de
palabras consecutivas, mejor conocido como bigramas; o en lugar de dos
palabras consecutivas, tres, es decir, trigramas, etc. También podemos contar
otros aspectos más específicos, como las palabras con mayúsculas, los signos
de puntuación, los nombres propios, las categorías de las palabras, patrones
sintácticos, etc. Cada una de estas es una representación diferente del texto,
y son tipos de vectores diferentes. En otro próximo post, platicaremos de
estás opciones, por lo pronto vamos a enfocarnos la forma de comparar dos
vectores, que en nuestro caso se traduce a comparar dos textos.


Distancias
----------

Una distancia representa de manera numérica la cercanía o lejanía de dos
puntos. En nuestro caso, esos &quot;puntos&quot; estarán representados por los vectores
de dos documentos. La forma de calcular esa distancia es a través de funciones
matemáticas que tomen como argumentos dos vectores y regresen un valor. Estas
funciones además tienen que cumplir con las siguientes condiciones:

&lt;ol&gt;
&lt;li&gt;$ D(X,Y) \geq 0 $&lt;/li&gt;
&lt;li&gt;$ D(X,Y) = 0\ iff\  x=y$&lt;/li&gt;
&lt;li&gt;$ D(X,Y) = D(Y,X) $&lt;/li&gt;
&lt;li&gt;$ D(X,Z) \leq D(X,Y) + D(Y,Z)$&lt;/li&gt;
&lt;/ol&gt;


Si una función cumple con estas condiciones se le conoce como *métrica*. La
primera condición establece que las distancias siempre tienen que ser
positivas. La segunda condición asegura que la única vez que la distancia sea
cero sea porque son el mismo objeto. La tercera condición establece que no
importa la dirección en que se calcula la distancia, esta debe ser la misma
para dos objetos. Y finalmente, la cuarta condición establece  que la
distancia entre dos puntos no podrá ser menor a la suma de la distancias de
estos puntos con un tercero, a esta última se le conoce como la desigualdad
del triángulo. Si alguna métrica no cumple con alguna de estas condiciones, se
dice que estamos ante un *pseudo-métrica*.


Como podrán imaginarse existen varias formas de calcular la distancia entre
dos textos, dado que existen varias métricas para calcular estas distancias. A
continuación vamos a revisar algunas de éstas: _Jaccard_, _Sorensen_, _Masi_, _Ochai_, _h0_, _Euclidiana_ y _Coseno_.

En particular *Jacard*, *Masi*, *Sorensen*, y *Ochai* son distancias
binarias y no toman en cuenta a las cantidades representados en los vectores.
El resto son distancias pesadas y sí toman los toman en cuenta, aunque también
vamos a mostrar versiones pesadas de estas distancias. Adicionalmente, se
presenta *overlap* que no es una *pseudo-métrica*.

&lt;center&gt;
&lt;a id=&quot;jaccard&quot;&gt;&lt;/a&gt;
**Jaccard**
&lt;/center&gt;

Una idea central es medir que tantos elementos comparten ambos vectores.
La métrica Jaccard sigue esta intuición. La fórmula se representa de la forma
siguiente:

$$ D_{jaccard}(X,Y) = 1 - { \sum x_i \land  y_i  \over  \sum x_j \lor  y_j  }
$$

Esta fórmula indica que para la distancia entre los vectores $X$ y $Y$ hay que
calcular los índices en común, es decir índices de un escalar con valor mayor
a cero en ambos vectores; y dividirlos entre la cantidad de índices mayores a
cero, sin importar si en el otro vector ese índice es cero.  Este valor lo
restamos de uno para que $1$ represente que los dos valores están lejanos y
$0$ que los vectores están cercanos.

En términos de documentos, la métrica Jaccard consiste en dividir el
vocabulario común de los documentos, entre el vocabulario de la unión de
ambos documentos. En caso de documentos similares, el vocabulario común es
igual al vocabulario de ambos documentos, por lo tanto la distancia cero.
Pero en caso de ser distintos el vocabulario en común es cero, y por lo tanto
la distancia uno.

Para experimentar puedes pegar un segundo texto en la siguiente área de texto
y será comparado con el texto que pegaste anteriormente. Oprime el botón para
calcular la distancia.
&lt;center&gt;
&lt;form name=&quot;texto2&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;Escribe o pega un texto aquí
&lt;/p&gt;
&lt;p&gt;
&lt;textarea id=&quot;tatexto2&quot; rows=&quot;12&quot; style=&quot;width: 720px&quot;  name=&quot;inputbox&quot;
value=&quot;&quot;&gt;&lt;/textarea&gt;
&lt;/p&gt;
&lt;/form&gt;
&lt;/center&gt;

&lt;form name=&quot;jaccard&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Jaccard&quot;
onClick=&quot;jaccardf('tatexto1','tatexto2','jaccard-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;jaccard-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
**Jaccard pesado** &lt;/center&gt;

En la versión anterior de la distancia de Jaccard no se tomó en cuenta los
escalares de los vectores, sino solamente los índicesi (lo anterior porque
está basada en operaciones binarias *AND* y *OR*).  La siguiente definición de
la fórmula arregla esta situación:

$$ D_{wjacard}(X,Y) = 1 - { \sum min(x_i,y_i)  \over  \sum max(x_j,y_j)  } $$

En términos de texto, la métrica de Jaccard pesada es la relación que existe
de la cantidad de palabras compartidas en ambos documentos, entre la cantidad
potencial máxima que se pudieron haber compartido. Por ejemplo, si el
documento uno es &quot;a b c c c&quot; y documento dos es &quot;a a b&quot;, las palabras
compartidas son 2 (a y b), pero la máxima que se pudo compartir es 2 as, 1 be
y 3 ces, igual a 6.

&lt;form name=&quot;wjaccard&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Jaccard pesada&quot;
onClick=&quot;wjaccardf('tatexto1','tatexto2','wjaccard-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;wjaccard-result&quot;&gt;&lt;/div&gt;

&lt;center&gt;
&lt;a id=&quot;sorensen&quot;&gt;&lt;/a&gt;
**Sorensen** &lt;/center&gt;

Sorensen propone una relación parecida a Jaccard, pero ahora en relación a
la cantidad de índices involucrados, la fórmula luce así:


$$ D_{sorensen}(X,Y) = 1 - { 2* \sum x_i \land  y_i  \over  \sum x_j \land
1 + \sum y_k \land 1  } $$


Para documentos consiste en dividir la cantidad de vocabulario común,
incluimos tanto las palabras tipos del primer documento como los del
segundo documentos, como son las comunes entre vectores se repiten y por
eso multiplicamos por dos. Este valor lo dividimos entre todas las
palabras tipo de ambos ambos documentos. A diferencia de Jaccard, no
cuidamos que un índice aparezca una sola vez en la operación.

&lt;form name=&quot;sorensen&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Sorensen&quot;
onClick=&quot;sorensenf('tatexto1','tatexto2','sorensen-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;sorensen-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
**Sorensen pesado** &lt;/center&gt;

Si pensamos que las cantidades de los vectores se suman a una masa de
valores, Sorensen pesado se traduce en la relación que existe entre la
masa  compartida por ambos vectores entre el total de la masa de ambos
vectores.

$$ D_{sorensen}(X,Y) = 1 - {  \sum min(x_i,y_i) \over  \sum x_i + \sum y_j
} $$

En términos de documentos es la relación entre las palabras compartidas
por ambos documentos entre el total de palabras usadas por ambos
documentos.

&lt;form name=&quot;wsorensen&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Sorensen pesada&quot;
onClick=&quot;wsorensenf('tatexto1','tatexto2','wsorensen-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;wsorensen-result&quot;&gt;&lt;/div&gt;

&lt;center&gt;
&lt;a id=&quot;overlap&quot;&gt;&lt;/a&gt;
**Overlap**
&lt;/center&gt;

Con Jaccard y Sorensen surge el problema que cuando uno de los vectores tiene
mucho más componentes que el otro causa que las distancia tienda a cero
independientemente si los valores en común sean muy parecidos.
Overlap trata de disminuir este problema dividiendo el número de valores
comunes entre el vector &quot;más pequeño&quot;.

$$ D_{overlap}(X,Y) = 1 - { \sum x_i \land y_i  \over  min(\sum x_j \land 1,
\sum y_k \land 1) } $$

En términos de documentos corresponde a dividir el vocabulario común, entre el
vocabulario más pequeño correspondiente a uno de los documentos.

&lt;form name=&quot;woverlap&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Overlap&quot;
onClick=&quot;overlapf('tatexto1','tatexto2','overlap-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

Sin embargo, esta formulación tiene el efecto que ya no se trata de una métrica
sino una pseudo-métrica. Porque cuando un documento está contenido en otro la
distancia es de cero, y esto va encontra de la segunda condición de la métricas
que establece que la distancia solo puede ser cero cuando se trata del mismo
documento.


&lt;div id=&quot;overlap-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
**Overlap pesado** &lt;/center&gt;

Regresando a nuestra intuición de masa, esta versión de overlap divide la masa
común entre vectores, entre la masa más pequeña correspondiente a uno de los
vectores.

$$ D_{overlap}(X,Y) = 1 - {  \sum min(x_i,x_i) \over  min(\sum x_j,\sum y_k) }
$$

En términos de documentos corresponde a la cantidad de palabras comunes, entre
la cantidad del documento más pequeño.

&lt;form name=&quot;woverlap&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Overlap pesada&quot;
onClick=&quot;woverlapf('tatexto1','tatexto2','woverlap-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;woverlap-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
&lt;a id=&quot;masi&quot;&gt;&lt;/a&gt;
**Masi** &lt;/center&gt;

Masi (Measuring Agreement on Set-Valued Items) sigue un esquema similar al de overlap, pero considerá al vector &quot;más
grande&quot;.

$$ D_{masi}(X,Y) = 1 - { \sum x_i \land  y_i  \over  max(\sum x_j \land 1,
\sum y_k \land 1) } $$

En términos de documentos corresponde a dividir el vocabulario común, entre el
vocabulario más grande correspondiente a uno de los documentos.

&lt;form name=&quot;wmasi&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Masi&quot;
onClick=&quot;masif('tatexto1','tatexto2','masi-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;masi-result&quot;&gt;&lt;/div&gt;

&lt;center&gt;
**Masi pesado** &lt;/center&gt;

De forma similar Masi divide la masa común entre vectores entre la masa del
vector con mayor masa.

$$ D_{masi}(X,Y) = 1 - {  \sum min(x_i,y_i) \over  max(\sum x_j,\sum y_k) }
$$


En términos de los documentos consiste en dividir la cantidad de palabras
compartidas entre las palabras del documento más grande.

&lt;form name=&quot;wmasi&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Masi pesada&quot;
onClick=&quot;wmasif('tatexto1','tatexto2','wmasi-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;wmasi-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
&lt;a id=&quot;h0&quot;&gt;&lt;/a&gt;
** h0 ** &lt;/center&gt;

h&lt;sub&gt;0&lt;/sub&gt; no tiene una versión binaria. Mezcla Sorensen y la intuición
de dividir la masa compartida y dividirla entre la masa potencialmente
compartida entre ambos vectores.


$$ D_{h_0}(X,Y) = 1 - { \sum min(x_i,y_i)  \over  \sum max(x_j,y_j) } $$

En término de documentos divide las palabras compartidas de los
documentos, entre la masa potencialmente compartida entre ambos
documentos.

&lt;form name=&quot;wh0&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;h0&quot;
onClick=&quot;wh0f('tatexto1','tatexto2','wh0-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;wh0-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
&lt;a id=&quot;euclidiana&quot;&gt;&lt;/a&gt;
** Euclidiana ** &lt;/center&gt;

La distancia euclidiana es la que estamos acostumbrados y usamos
habitualmente. Corresponde a la longitud de una línea recta entre dos
vectores. En nuestra vida cotidiana estos vectores representan puntos en
el espacio 2D o 3D. Ésta definida por la fórmula:

$$ D_{euclidian}(X,Y) = 1 - { \sqrt { \sum (x_i-y_i) ^2 }  \over  { \sum
(x_j-x_j) ^2 }  } $$

En términos del documento es difícil imaginarse a que corresponde esta
distancia. Como me lo imagino, es que esta distancia codifica cuantos
cambios habría que hacer en un documento para llegar al otro. Sin embargo,
no hay que confundir con la distancia de edición (que exactamente mide
esos cambios pero en una secuencia de palabras).

&lt;form name=&quot;weuclidian&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Euclidiana&quot;
onClick=&quot;weuclidianf('tatexto1','tatexto2','weuclidian-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;weuclidian-result&quot;&gt;&lt;/div&gt;

&lt;center&gt;
&lt;a id=&quot;coseno&quot;&gt;&lt;/a&gt;
** Coseno **
&lt;/center&gt;

Coseno es menos popular que la euclidiana pero también tiene su fundamento
en aspectos geométricos. Esta distancia codifica el ángulo entre vectores,
para ser específicos el coseno del ángulo.

$$ D_{coseno}(X,Y) = { \sum x_i*y_i   \over  { \sqrt { \sum x_j ^2 }}  {
\sqrt { \sum y_k ^2 }}  } $$

Otra vez, es difícil imaginarse desde el punto de vista del documento que
significa esta métrica entre el ángulo de documentos.

&lt;form name=&quot;wcosine&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Coseno&quot;
onClick=&quot;wcosinef('tatexto1','tatexto2','wcosine-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;wcosine-result&quot;&gt;&lt;/div&gt;


&lt;center&gt;
&lt;a id=&quot;ochai&quot;&gt;&lt;/a&gt;
**Ochai** &lt;/center&gt;

La métrica Ochai se puede pensar como la versión binaria de la coseno.

$$ D_{ochai}(X,Y) = 1 - { \sum x_i \land  y_i  \over  \sqrt { \sum x_j
\land 1 \sum y_k \land 1 } }
$$

&lt;form name=&quot;wochai&quot; action=&quot;&quot; method=&quot;GET&quot;&gt;
&lt;p&gt;
Para calcular esta distancia entre los documentos oprime el botón:
&lt;input type=&quot;button&quot; name=&quot;button&quot; value=&quot;Ochai&quot;
onClick=&quot;ochaif('tatexto1','tatexto2','ochai-result')&quot;&gt;&lt;/input&gt;
&lt;/p&gt;
&lt;/form&gt;

&lt;div id=&quot;ochai-result&quot;&gt;&lt;/div&gt;

Ejemplo
-------

Como ejemplo, tomé las versiones
[2](http://www.gnu.org/licenses/gpl-2.0.txt) y
[3](http://www.gnu.org/licenses/gpl-3.0.txt) de licencia GNU de software
libre estos son los resultados de la comparación para cada una de las
distancias:

* **Jaccard**: 0.5581
* **Jaccard pesado**: 0.5574
* **Sorensen**: 0.3871
* **Sorensen pesado**: 0.1452
* **Overlap**: 0.2122
* **Overlap pesado**: 0.0634
* **Masi**: 0.4984
* **Masi pesado**: 0.5438
* **h_0**: 0.4697
* **Euclidiana**: 0.0033
* **Coseno**: 0.0024
* **Ochai**: 0.3714

Podemos imaginar ambos documentos deben ser &quot;cercanos&quot; ya que uno es la
evolución del otro. Esta similitud se ve reflejada en los valores
relativamente bajos. Por supuesto, la pregunta que surge aquí es ¿Cuál es
la verdadera distancia? De hecho esa pregunta originó este post, y trabajo
anterior en el que tratamos de unificar las distancias con el fin de
identificar los autores de textos, bajo la hipótesis que documentos del
mismo autor están cercanos entre si.

Este post tiene su origen en el trabajo realizado con &lt;a
href=&quot;http://www.clef-initiative.eu/documents/71612/61255b8a-2ca7-491d-bebd-3d874e54148a&quot;&gt;
Paola Ledesma, Gibrán Fuentes, Gabriela Jasso y Ángel Toledo&lt;/a&gt;.

---
Referencias

&lt;a id=&quot;referencias&quot;&gt;&lt;/a&gt;

* [Espacios vectoriales](http://en.wikipedia.org/wiki/Vector_space)
* [Modelo de Espacio
vectorial](http://en.wikipedia.org/wiki/Vector_space_model)
* [Distancias en
Numpy](http://docs.scipy.org/doc/scipy/reference/spatial.distance.html)



[unamch]:https://www.google.com/maps/preview#!data=!4m18!3m17!1m1!1sCentro+Historico%2C+Mexico!1m5!1sUniversidad+Nacional+Aut%C3%B3noma+de+M%C3%A9xico%2C+Av.+Universidad+3000%2C+Ciudad+Universitaria%2C+Coyoac%C3%A1n%2C+04510+Ciudad+de+M%C3%A9xico%2C+Distrito+Federal%2C+Mexico!2s0x85ce00071fca0bad%3A0x6074a3db95bb232e!3m2!3d19.318951!4d-99.184306!3m8!1m3!1d39377!2d-99.1860896!3d19.3216945!3m2!1i1920!2i1004!4f13.1&amp;fid=0
[tijuanatapachula]:https://www.google.com/maps/preview#!data=!4m18!3m17!1m5!1sTijuana%2C+Baja+California%2C+Mexico!2s0x80d93810036fbaf3%3A0xc0cd7a68bb7188f4!3m2!3d32.4888212!4d-116.9616941!1m1!1sTapachula%2C+Mexico!3m8!1m3!1d19183743!2d-108.0754122!3d26.1112765!3m2!1i1920!2i1004!4f13.1&amp;fid=0
</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Hello World</title>
    <id>hello_world2</id>
    <updated>2013-07-03T00:00:00Z</updated>
    <published>2013-07-03T00:00:00Z</published>
    <link href="/#/post/hello_world2" />
    <author>
      <name>Ivan V. Meza</name>
    </author>
    <content type="text">
**Hello World**, from my new blog!!

``` python
print &quot;hello world&quot;
```

This is an simple example.</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">MFCCs</title>
    <id>MFCC</id>
    <updated>2013-03-28T00:00:00Z</updated>
    <published>2013-03-28T00:00:00Z</published>
    <link href="/#/post/MFCC" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">

Un problema que surge inmediatamente al trabajar con archivos de audio es
la gran variabilidad de los valores en el dominio de la amplitud. Por
ejemplo el siguiente audio[&lt;sup&gt;1&lt;/sup&gt;](#footnotes):

&lt;iframe width=&quot;100%&quot; height=&quot;166&quot; scrolling=&quot;no&quot; frameborder=&quot;no&quot;
src=&quot;https://w.soundcloud.com/player/?url=http%3A%2F%2Fapi.soundcloud.com%2Ftracks%2F85131770&quot;&gt;&lt;/iframe&gt;

esta compuesto por una secuencia consecutiva de 984,000 valores/muestras
que representan el 'volumen' del sonido para diferentes tiempos en la
grabación.  Tratar de identificar patrones en esta secuencia de valores es
una tarea titánica, además que no representa la forma en como el oído
humano escucha, que es en el dominio de la frecuencia en lugar en el
dominio de la amplitud. Los coeficientes cepstrales en la frecuencia-Mel
tratan de resolver este problema (*Mel-frequency cepstral coeficients*,
*MFCC*). Para lograr esto se intercambian segmentos/ventanas de la señal
original con 13 valores/coeficientes. En la práctica una configuración
común es reducir 160 muestras de amplitud a 13 valores, que significa que
nuestro audio original queda representado por aprox. 79,950 valores.

MFCCs no solo están motivados por su efecto en comprimir los datos, sino
también tienen una motivación matemática, biológica y de procesamiento de
señales. En este *post* explicaremos como se calculan las MFCCs y trataré
de presentar algunas de las motivaciones detrás de los cálculos. Además
presentaré el código detrás de cada una de los ejemplos. Para reproducir
esto es necesaria la librería *audioprocessing* que estamos desarrollando
en el [Grupo Golem](http://golem.iimas.unam.mx) y que está disponible en
[Audio Golem](http://golem.iimas.unam.mx/git?p=golemaudio.git;a=summary).

El dominio de la frecuencia
---------------------------

Como su nombre lo sugiere la frecuencia tiene que ver con periodicidad, en
este caso, periodicidad matemática. En términos matemáticos toda función
en el tiempo puede ser representada por una combinación de funciones
periódicas (estas son funciones que se repiten de manera infinita, por
ejemplo una senoide).  Una analogía culinaria son los ingredientes de un
platillo, el platillo es la función en el tiempo y los ingredientes son
las funciones periódicas; entonces dado un platillo, lo podemos
representar por una combinación de sus ingredientes, que es lo que
representa la receta. Las matemáticas detrás de estas ideas son muy
bonitas, algo complicadas, pero también muy generosas. Creo que no tengo
que explicar porque bonitas, complicadas porque originalmente la función
en el tiempo tiene que ser también periódica, afortunadamente con
matemáticas discretas esto no es un requisito, pero ahora en lugar de
obtener una receta única obtenemos una secuencia de éstas. Y finalmente,
son generosas porque nos permiten ir de amplitud a frecuencia y en
reversa, cosa que no podemos hacer con nuestra analogía culinaria, una vez
que preparamos la receta, muy difícilmente podemos regresar a los
ingredientes originales.

Regresando a nuestra señal de audio, el dominio de la frecuencia nos va a
permitir identificar que 'tonos'/frecuencias la componen; como no se trata
de una función periódica, esta limitada en el tiempo, obtendremos estos
'tonos' para diferentes segmentos de la señal de audio. Es decir,
obtendremos como cambian los tonos que componen a la señal conforme avanza
el tiempo. Muchos reproductores de audio hoy en día muestran esta
información en formato de barras por grupos de frecuencias, es más nos
dejan jugar con los límites de estas frecuencias para ecualizar el audio,
pero, por el momento no vamos a hablar de ecualización.

El algoritmo
------------

Los MFCCs van a representar a elementos en el dominio de la frecuencia,
nada más que vamos a utilizar alguna de nuestra intuición fonética para
poderlos reducir en número a valores muy representativos. Los pasos a
seguir son los siguientes:

1. Dividir la señal en ventanas del mismo tamaño (se recomienda que estén
intercaladas)
2. De preferencia se una ventana de Hamming por cada ventana
3. Para cada ventana calcular la transformada discreta de Fourier
4. Con los valores de la transformada de Fourier calcular el
*periodograma* que representa la energía por cada valor de frecuencia.
5. Filtrar las frecuencias y energías del periodograma usando un banco de
filtros Mel.
6. Calcular el logaritmo de la energía por cada uno de los filtros.
7. Calcular la transformada coseno discreta de las energías
8. Quedarse con los valores  1 a 13 de esta transformada, que representan a
los 13 coeficientes MFCCs

A continuación iremos viendo cada una de las etapas. Para ilustrar estos pasos
y cada uno de los puntos utilizaré los 10 primeros segundos de la grabación
presentada al principio. Para preparar el ambiente para los ejemplos ejecutar:

``` python
import numpy as np
import matplotlib.pyplot as plt
import scikits.audiolab as audiolab
sndf=audiolab.Sndfile('Turdus_migratorius_Esau_Villareal.wav','r')
data=sndf.read_frames(sndf.samplerate*10)
sndf.close()
```

Este código guarda los primeros 10 segundos de la grabación en la variable
`data`, la cual podemos graficar en el tiempo de la siguiente forma:

``` python
plt.plot(data)
# Set the x axis values to seconds
plt.xticks([i*16000 for i in range(11)],[&quot;%ds&quot;%i for i in range(11)])
plt.show()
```

&lt;hr/&gt;
&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig1.png'&gt;

Lo que nos muestra un total de 160,000 valores por los 10 segundos de la
grabación (en este caso el *sample rate* de la grabación es de 16000
muestras por segundo).


Ventaneo
--------

Como habíamos establecido dado que nuestra señal de audio no es periódica
no es posible calcular sus componentes en frecuencia para toda ella. Por
lo que se procede calcular los componentes para segmentos de esta. A estos
segmentos se le conocen como ventanas. Podemos pensar que lo que hacemos
es suponer que lo que está en la ventana representa a una función
periódica, por lo que podemos aplicar la matemática que nos permite saber
los componentes para una función periódica.

Una vez que tenemos los componentes para una ventana nos podemos mover a
la siguiente ventana en el tiempo y calcular los componentes para esa
nueva ventana. De manera práctica obtendremos una secuencia de como
evolucionan los componentes en el tiempo.

En este proceso hay que definir dos parámetros, el primero es el tamaño de
la ventana y el segundo la cantidad de muestras a brincar entre ventanas.
Lo que queremos es que la ventana cubra suficientes muestras de tal forma
que absorba la riqueza de componentes en frecuencia y que el brinco sea lo
suficientemente pequeño que capture un continuo en los componentes, pero
que nos permita reducir el número de muestras.  Para una *sample rate* de
16000 los valores comunes son un tamaño de ventana de 400 y un brinco de
160 muestras entre ventanas.

El siguiente código dibuja la primera y segunda ventana de nuestra
grabación de manera continua con diferentes colores.

``` python
n1=data[:400]
win2=np.zeros(560,'double')
win2[160:560]=data[160:560]
plt.plot(win1)
plt.plot(win2)
plt.show()
```

&lt;img src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig1.png'/&gt;

Como pueden observar ambas ventanas se sobre imponen y de hecho comparten
valores entre sí, del 160 al 400.

Hamming
-------

La ventana Hamming nos ayuda ha hacer *smooth* la información en la
ventana de la señal original, esto ayudará a filtrar frecuencias espurias
que aparecen por cortar abruptamente la señal. La siguiente figura muestra
la ventana Hamming, una ventana de nuestra señal y la señal después de
pasarla por la ventana Hamming:

``` python
ham=np.hamming(400)
win=data[64000:64400]
f,ax=plt.subplots(3)
ax[0].plot(ham)
ax[1].plot(win)
ax[2].plot(win*ham)
f.show()
```

&lt;img src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig3.png'
title=&quot;Grabación de audio en amplitud&quot;/&gt;

Transformada Discreta de Fourier
--------------------------------

La transformada discreta de Fourier es la operación que nos permite
calcular los componentes en el dominio de la frecuencia.
Desafortunadamente, la transformada nos da componentes en el dominio de
los números imaginarios, que son los que utilizamos para representar
información sobre la amplitud de las funciones periódicas por grupos de
frecuencias. Sin embargo en lo que estamos interesados es en la energía en
esas frecuencias, por lo que elevamos al cuadrado la información real e
imaginaría para extraer la magnitud de la energía.  Con esta información,
podemos sacar el *periodograma* para esa ventana de la siguiente forma:

``` python
s=np.fft.rfft(win*ham,512)
p=(s.real**2+s.imag**2)/len(win)
plt.plot(p)
plt.show()
```

Como vemos primero se calcula la transformada de Fourier rápida para
números reales y luego se eleva al cuadrado tanto la parte real como
imaginaría y se normaliza por el tamaño de la ventana. En particular se
pide que la frecuencias se alojen en 512 recipientes/bins, pudimos elegir
algo más granular pero 512 es común en aplicaciones de voz. Este código
resulta en la figura:

&lt;hr/&gt;
&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig4.png'
title=&quot;Grabación de audio en amplitud&quot;/&gt;

Vemos que esta particular ventana tiene componentes alrededor de los
recipientes número 85. Además vemos que el tamaño de las frecuencias es
menor a 512, de hecho es la mitad, esto porque los valores son simétricos
y representan frecuencias negativas, por lo que podemos obviar esos
valores. Ahora si calculamos cada uno de los *periodogramas* para todas
las ventanas en nuestra señal y la graficamos con respecto al tiempo se
obtiene la siguiente figura:

&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig42.png'
title=&quot;Grabación de audio en amplitud&quot;/&gt;

Lo que vemos es que altas frecuencias no hay mucha información, pero sí a
bajas. También hay que notar que podemos describir toda nuestra señal
ahora con 257,000 valores. Es decir, el número de valores aumento de
160,000 para los diez segundos, por lo que vamos a necesitar filtrar
algunos de estos valores.

Filtros Mel
-----------

Un filtro Mel es un filtro triangular que ayuda a obtener información de
una banda de frecuencia.  Estas bandas están basadas en la percepción del
oído humano, en donde frecuencias bajas son más granulares y con mayor
peso y frecuencias altas más amplias pero con menor pes pero con menor
peso. La siguiente figura muestra las bandas para nuestras 257 recipientes
de frecuencias:

``` python
from golemaudio.audiofun import mel
plt.plot(mel.MELfilterbank_speech)
plt.show()
```

&lt;hr/&gt;
&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig5.png'
title=&quot;Grabación de audio en amplitud&quot;/&gt;

Como se puede apreciar un filtro MEL se concentra en las frecuencias bajas
y abarca pocas frecuencias, conforme crece las frecuencias comienza
abarcar más frecuencias pero la altura del filtro disminuye. Esta forma de los
filtros tienen que ver como percibimos el volumen en frecuencias altas contra
el volumen en frecuencias bajas. En el ejemplo se presentan un total de 26
filtros/bandas. Cada filtro se va a utilizar para concentrar las energías en
la banda en un solo valor, de esta forma después de aplicar el filtro
obtendremos 26 valores. Pero además vamos a modificar la escala de la energía
por una logarítmica  que nos va a alizar los valores y hacer más manejables.
Adelante se muestra el efecto de este proceso en una ventana de la señal.


``` python
f,ax=plt.subplots(3)
ax[0].plot(p)
ax[1].plot(np.dot(p,mel.MELfilterbank_speech).clip(1e-5,np.inf))
ax[2].plot(np.log(np.dot(p,mel.MELfilterbank_speech).clip(1e-5,np.inf)))
f.show()
```

&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig6.png'
title=&quot;Energía en 26 bandas de frecuencias&quot;/&gt;


Podemos hacer este cáculo para todos los periodogramas de nuestra señal,
lo que nos da la siguiente figura:

&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig62.png'
title=&quot;Energía en 26 bandas de frecuencias&quot;/&gt;


Hay que notar, que el número de valores se redujo de 257,000 a 26,000.  Para
una mejor comparación dibujamos para el primer segundo de audio de el
periodograma y de los coeficientes Mel.

&lt;hr/&gt;
&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig63.png'
itle=&quot;Energía en 26 bandas de frecuencias&quot;/&gt;

Transformada coseno discreta
----------------------------

De hecho es la escala  *log* del la energía de los coeficientes MEL lo que
convierte a esta señal en un coeficiente *cepstral*.  El prefijo &quot;*ceps*&quot;
es el inverso de &quot;*spec*&quot; (de espectral) y lo que señala es que podemos
tratar dicha señal como si fuera una señal en amplitud. Por eso, el
siguiente paso es aplicar una transformada de coseno a las coeficientes
MEL. La intuición desde paso es desde el punto de vista de procesamiento
de señales, que nos va a permitir comprimir dicha señal en elementos más
informativos. De hecho de años de experiencia en el campo de
reconocimiento de voz, de esta transformada coseno nada más vamos a
conservar del segundo al treceavo valor, el resto es ignorado.  El
siguiente código calcula esta compresión para una ventana, compara la
escala log de los coeficiente Mel con los MFFCs para esa ventana :

``` python
from scipy.fftpack import dct
mlog=np.log(np.dot(p,mel.MELfilterbank_speech).clip(1e-5,np.inf))
f,ax=plt.subplots(2)
ax[0].plot(mlog)
ax[1].plot(d)
f.show()
```

&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig7.png'
title=&quot;MFCCs para una ventana de audio&quot;/&gt;

Finalmente, podemos calcular las MFCCs para todas las ventanas de audio,
el resultado es el siguiente para el primer segundo de la grabación:

&lt;img class='center'  src='http://turing.iimas.unam.mx/~ivanvladimir/images/mfcc_fig72.png'
title=&quot;MFCCs para el primer segundo de audio&quot;/&gt;


Notas finales
-------------

De esta forma es posible calcular los MFCCs para una señal. En resumen el
procedimiento fue: por ventana, identificar la energía para los
componentes en el dominio de la frecuencia, filtrar estos componentes con
un modelo de la percepción humana y comprimir estos valores aun más. Los
coeficientes resultantes pueden ser utilizados para tareas de aprendizaje
automático en donde se les denominará como los *features*/características
de la señal.

Agradezco a Esaú Villareal por facilitarnos acceso a su grabación del ave
*Turdus Migratorius*.

---
Referencias

&lt;a id=&quot;referencias&quot;&gt;&lt;/a&gt;


* [Tutorial Mel Frequency Cepstral Coefficient
](http://www.practicalcryptography.com/miscellaneous/machine-learning/guide-mel-frequency-cepstral-coefficients-mfccs/)
* [Implementación de MFCC basada en tutorial
](https://github.com/jameslyons/python_speech_features)
* [Implementación alternativa de MFCC basada en Sphinx
](https://code.google.com/p/sphinx-am2wfst/source/browse/t3sphinx/mfcc.py)
* [Otra implementación en python
](https://github.com/jameslyons/python_speech_features)
* [Otra implementación en Octave/Matlab
](http://labrosa.ee.columbia.edu/matlab/rastamat/)
* [Ventana de Hamming
](http://en.wikipedia.org/wiki/Window_function#Hamming_window)
* [Transformada de Fourier
](http://en.wikipedia.org/wiki/Fourier_transform)
* [Transformada discreta de Fourier
](http://en.wikipedia.org/wiki/Discrete_Fourier_transforma)
* [Transformada Rápida de Fourier
](http://en.wikipedia.org/wiki/Fast_Fourier_transform)
* [Periodograma](http://en.wikipedia.org/wiki/Periodogram)
* [Escala de Mel](http://en.wikipedia.org/wiki/Mel_scale)
* [Banco de filtros Mel
](http://www.ee.columbia.edu/ln/LabROSA/doc/HTKBook21/node54.html )
* [Cepstrum de frecuencia-Mel
](http://en.wikipedia.org/wiki/Mel-frequency_cepstrum)
* [Escala logarítmica](http://en.wikipedia.org/wiki/Logarithmic_scale)
* [Transformada discreta de coseno
](http://en.wikipedia.org/wiki/Discrete_cosine_transform)
* [Coeficientes de Cepstrum de frecuencia-Mel
](http://en.wikipedia.org/wiki/Mel-frequency_cepstrum)

---
&lt;a id=&quot;footnotes&quot;&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt; Grabación del ave *turdus migratorious*
hecha por Esaú Villareal como parte de su tesis de licencitura en la
Ciudad de México.

</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Audiolab: Audio en Python</title>
    <id>audio_en_python</id>
    <updated>2013-03-25T00:00:00Z</updated>
    <published>2013-03-25T00:00:00Z</published>
    <link href="/#/post/audio_en_python" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
Aunque hasta ahora me había resistido a trabajar con grabaciones de audio,
dado los proyectos en los que estamos trabajando en el [Grupo Golem](
http://golem.iimas.unam.mx ) he terminado con la necesidad de procesar una gran cantidad de
grabaciones. Ya sea para hacer scripts de evaluación, identificar
actividad o para extraer caracteristicas del audio. Como es esperarse en
mi caso he estado utilizando python, sobretodo por la necesidad de
automatizar las tareas.

Python tiene varias librerías y herramientas para trabajar con
audio[&lt;sup&gt;1&lt;/sup&gt;](#footnotes). Uno de los requisitos que rápido surgió fue que la librería
debería ser compatible con *ScyPy* y *NumPy*, inmediatamente identificamos a
[Audiolab][AudioLab]. Esta es un librería que puede leer de muchos formatos y lo
más importante nos entrega una estructura `numpy` directamente!

A continuación describimos alguna información sobre la documentación, la
instalación y un ejemplo de uso que encontramos útil.

Documentación
-------------

En un principio estaba algo confundido sobre que era [Audiolab][AudioLab].

* [Audiolab][AudioLab] es un wrapper sobre la librería [libsndfile][]
originalmente escrita en *C*
* [Audiolab][AudioLab] es uno de los SciPy Toolkits mejor conocidos como
[scikits][]
* [Audiolab][AudioLab] fue desarrollado por [David Cournapeau][david]
* La documentación de [audiolab][AudioLab] puede ser localizada en [aquí][doc]
* [Audiolab][AudioLab] tiene una minipágina en el sitio de [Cournapeau][Audiolab2]
* La librería la pueden [descargar aquí][download]

Instalación
-----------

Requisitos:

* NumPy, libsndfile, libasound


En ubuntu podemos instalar este software de la siguiente manera:

``` bash
sudo apt-get install python-dev python-numpy python-setuptools
sudo apt-get install libsndfile-dev libasound2-dev
```

La instalación la podemos hacer con `easy_install` ya que se instaló
`python-setuptools` de la siguiente forma:

``` bash
sudo easy_install scikits.audiolab
```

Alternativamente se puede bajar el paquete e instalarlo de la siguiente
forma:

``` bash
tar -xzvf scikits.audiolab-0.11.0.tar.gz
cd scikits.audiolab-0.11.0/
python setup.py build
sudo python setup.py install
```

Ejemplo
-------

Para el siguiente ejemplo se necesita un archivo de audio con más de un
segundo de duración, sino tienes uno a la mano puedes bajar uno de nuestro canal de
[SoundCloud]( https://soundcloud.com/golem-audio ). En el siguiente código
nos vamos a referir al archivo como `audio.wav` si tu archivo no se llama
así sustituye por el nombre correcto.

La idea del ejemplo es dibujar el
[espectograma]( http://es.wikipedia.org/wiki/Espectrograma ) del primer
segundo del archivo `audio.wav`, para lo cual será necesaria la librería
[*matplotlib*]( http://matplotlib.org/ ). El código lo puedes copiar y
ejecutar como un script de python o de manera interactiva con `ipython`.

``` python
import numpy as np
import matplotlib.pyplot as plt
import scikits.audiolab as audiolab

sound=audiolab.sndfile('audio.wav','read')
data=sound.read_frames(sound.get_samplerate())
spectogram=plt.specgram(data)
plt.show()
sound.close()
```


En el momento de ejecutarse `plt.show()` se desplegará el espectograma,
para terminar basta con cerrar la imagen. Un ejemplo de imagen a esperar
es:

&lt;img class='center'
src='http://turing.iimas.unam.mx/~ivanvladimir/images/audio_en_python_fig1.png'
title=&quot;Espectograma de un segundo de audio&quot;/&gt;
&lt;/a&gt;

Vamos a revisar línea por línea del código. La línea

``` python
import numpy as np
```

carga la librería `numpy` y le asigna el alias de `np`,

``` python
import matplotlib.pyplot as plt
```

carga la librería `matplotlib` y le asigna el alias de `plt`,

``` python
import scikits.audiolab as audiolab
```

finalmente, esta línea carga la librería `scikits.audiolab` y le asigna el
alias de `audiolab`.

``` python
sound=audiolab.sndfile('audio.wav','read')
```

Una vez con las librerías cargadas, se sbre el archivo de audio para
lectura y guarda la referencia en la variable `sound`.

``` python
data=sound.read_frames(sound.get_samplerate())
```

Esta línea, lee del archivo el equivalente a [sample rate](
http://en.wikipedia.org/wiki/Sampling_rate ) de muestras. El sample rate
dice cuantas muestras de audio se tomaron por segundo, como pedimos exactamente ésta
cantidad, únicamente leéremos el primer segundo del archivo. Esta
información se guarda en la variable `data`.

``` python
spectogram=plt.specgram(data)
```

Generamos el spectograma con la información guardadá en la variable `data`

``` python
plt.show()
```

Mostramos el espectograma.

``` python
sound.close()
```

Y finalmente, se cierra el archivo.

Y listo, de esa forma podemos abrir archivos de audio en python y
procesarlos con *numpy*.


- - -

&lt;a id=&quot;footnotes&quot;&gt;&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt; Estos son algunos sitios donde pueden
encontrar una lista de las
librerías y herramientas disponibles [Wiki audio in
Python]( http://wiki.python.org/moin/Audio ) y [Music software written in
Python]( http://wiki.python.org/moin/PythonInMusic )

[AudioLab]: http://projects.scipy.org/scikits/wiki/AudioLab &quot;Audiolab&quot;
[AudioLab2]:  http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/audiolab/index.html &quot;Audiolab&quot;
[download]: https://pypi.python.org/pypi/scikits.audiolab/ &quot;librería&quot;
[libsndfile]: http://www.mega-nerd.com/libsndfile/ &quot;libsndfile&quot;
[scikits]: http://projects.scipy.org/scikits/ &quot;scikits&quot;
[david]: http://www.ar.media.kyoto-u.ac.jp/members/david/index.html  &quot;desarrollador&quot;
[doc]:  http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/audiolab/sphinx/index.html &quot;documentación&quot;
</content>
  </entry>
  <entry xml:base="http://localhost/feed.atom">
    <title type="text">Hello World</title>
    <id>hello_world</id>
    <updated>2013-03-03T00:00:00Z</updated>
    <published>2013-03-03T00:00:00Z</published>
    <link href="/#/post/hello_world" />
    <author>
      <name>Ivan Vladimir Meza Ruiz</name>
    </author>
    <content type="text">
**Hello World**, from my new blog!!

``` python
print &quot;hello world&quot;
```

This is an simple example.</content>
  </entry>
</feed>
